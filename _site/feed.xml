<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rabbit</title>
    <description>有点理性，有点感性，有点执着，有点懒散，有点认真，有点浪的一枚普通程序媛</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 02 May 2017 12:58:24 +0800</pubDate>
    <lastBuildDate>Tue, 02 May 2017 12:58:24 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>ES6-let学习</title>
        <description>&lt;h1 id=&quot;let&quot;&gt;let&lt;/h1&gt;
&lt;h2 id=&quot;let命令&quot;&gt;let命令&lt;/h2&gt;
&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ES6新增命令，用于声明变量。用法类似var，但是其声明变量只在let命令所在代码块有效。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;aLet&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bVar&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;2;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;console.log(aLet);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Uncaught&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ReferenceError:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;aLet&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;defined(…)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;console.log(bVar);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;for循环计数器很适合let命令&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  for (let i = 0; i &amp;lt; 3; i++) {}
  console.log(i);  // Uncaught ReferenceError: i is not defined(…)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考考你?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 使用var变量
  var a = [];
  for (var i = 0; i &amp;lt; 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
  a[6]();    // ?结果
    
  // 使用let变量
  var a = [];
  for (let ii = 0; ii &amp;lt; 10; ii++) {
    a[ii] = function () {
      console.log(ii);
    };
  }
  a[6]();    // ?结果 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不存在变量提升&quot;&gt;不存在变量提升&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;变量提升:javascript是解释型语言，执行基本分为两个阶段，编译期(预编译)与运行期。在预编译阶段，它是用函数来划分作用域，然后逐层为其以var声明的变量(var变量)与函数定义开辟内存空间，再然后对var变量进行特殊处理，统统赋初始值为undefined。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  (function(){
    var str1 = &quot;1&quot;;
    var fun1 = function(){};
    var str2 = &quot;2&quot;;
    var str3 = &quot;3&quot;;
  })();
  // 同上代码
  (function(){
    var str1,fun1,str2,str3;
    str1 = &quot;1&quot;;
    fun1 = function(){};
    str2 = &quot;2&quot;;
    str3 = &quot;3&quot;;
  })();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;let不会发生’变量提升’，因此，变量一定要在声明后使用，否则报错。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  console.log(foo); // undefined
  console.log(bar); // Uncaught ReferenceError: bar is not defined(…)
  var foo = 2;
  let bar = 2;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;暂时性死区&quot;&gt;暂时性死区&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;考考你?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 使用var
  var tmp = 123;
  if (true) {
    console.log(tmp);
    var tmp;
  }
  // 使用let,运行结果
  var tmp = 123;
  if (true) {
    console.log(tmp);
    let tmp;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”(temporal dead zone，简称TDZ).&lt;/li&gt;
  &lt;li&gt;ES6明确规定，区块中使用let和const声明变量，则会形成封闭作用域，在声明之前使用变量会报错。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考考你?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 未使用let语句
  typeof myData;  
        
  // 使用let语句
  {
      typeof myData;
      let myData = 'myData';
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;h3 id=&quot;不允许重复声明&quot;&gt;不允许重复声明&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;let不允许在相同作用域内，重复声明同一个变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Uncaught SyntaxError: Unexpected token
  function fun1() {
      let num1 = 10;
      var num1 = 1;
  }
  // Uncaught SyntaxError: Unexpected token
  function fun2() {
      let num2 = 10;
      let num2 = 1;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不能在函数内部重新声明参数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function func(arg) {
    let arg; // 报错
  }
  function func(arg) {
    {
      let arg; // 不报错
    }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;h2 id=&quot;块级作用域&quot;&gt;块级作用域&lt;/h2&gt;
    &lt;h3 id=&quot;es5全局作用域和函数作用域&quot;&gt;ES5全局作用域和函数作用域&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考考你?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 场景一
  var date = new Date();
  function fun() {
    console.log(date);
    if (false) {
      var date = &quot;hello world&quot;;
    }
  }
  fun();
        
  // 场景二
  var str = 'hello';
  for (var j = 0; j &amp;lt; str.length; j++) {
    console.log(str[j]);
  }
  console.log(j);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;问题总结:ES5只有全局作用域和函数作用域，没有块级作用域
    &lt;ul&gt;
      &lt;li&gt;内层变量可能会覆盖外层变量&lt;/li&gt;
      &lt;li&gt;用来计数的循环变量泄露为全局变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;es6块级作用域&quot;&gt;ES6块级作用域&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;let实际上为JavaScript新增了块级作用域.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ES6允许块级作用域的任意嵌套,外层作用域无法读取内层作用域的变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;insane&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'Hello&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;World'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;console.log(insane);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Uncaught&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ReferenceError:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;insane&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;defined&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内层作用域可以定义外层作用域的同名变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;insane&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'Hello&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;World';&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;insane&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'Hello&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;World'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;块级作用域的出现，使得获得立即执行匿名函数（IIFE）不再必要.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // IIFE写法
  (function () {
    var tmp = ...;
    ...
  }());
        
  // 块级作用域写法
  {
    let tmp = ...;
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;块级作用域与函数声明&quot;&gt;块级作用域与函数声明&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明
    &lt;ul&gt;
      &lt;li&gt;浏览器支持在块级作用域中声明函数,因此上面代码可以正常运行,但是在‘严格模式’下会报错&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 情况一
  if (true) {
    function fun() {}
  }
        
  // 情况二
  try {
    function fun() {}
  } catch(e) {
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ES6引入了块级作用域，明确允许在块级作用域之中声明函数,并且函数声明语句的行为类似于let，在块级作用域之外不可引用。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // ES6严格模式
  'use strict';
  if (true) {
    function f() {}
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;h1 id=&quot;const&quot;&gt;Const&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;定义: 声明一个只读常量，一旦声明，常量的值就不可能改变.&lt;/li&gt;
  &lt;li&gt;注意点
    &lt;ul&gt;
      &lt;li&gt;const一旦声明变量，就必须立即初始化，不能留到以后赋值；&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const COLOR;  //Uncaught SyntaxError: Missing initializer in const declaration&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;const与let相同特性
        &lt;ul&gt;
          &lt;li&gt;只在声明所在的块级作用域内有效&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if (true) {
        const MAX = 5;
  }
  console.log(MAX);  // Uncaught ReferenceError: MAX is not defined
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;变量不提升&lt;/li&gt;
          &lt;li&gt;存在暂时性死区，只能在声明的位置后面使用&lt;/li&gt;
          &lt;li&gt;不能重复声明&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;复合类型(Object，Array等)的变量，可对其值进行修改，即const的定义保证了变量名指向地址不变。&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Array
  const foo = {};
  foo.prop = 123;
  console.log(foo);
  foo = {}; //Uncaught TypeError: Assignment to constant variable.
		
  // Object
  const arr = [];
  arr.push('Hello'); 
  arr.length = 0;    
  arr = ['World'];  // Uncaught TypeError: Assignment to constant variable  
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用const定义复合型变量达到真正的对象不可变，可以使用Object.freeze()方法冻结对象。&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 冻结对象和属性
  var constantize = (obj) =&amp;gt; {
    Object.freeze(obj);
    Object.keys(obj).forEach( (key, value) =&amp;gt; {
      if ( typeof obj[key] === 'object' ) {
        constantize( obj[key] );
      }
    });
  };
		
  const person = {name: 'penglu', age: 27};
  constantize(person);
  person.name = 'lee'; //无法修改，但是不会报错
  const arr = ['one', 'two'];
  constantize(arr);
  arr.push('three');  // Uncaught TypeError: Can't add property 2, object is not extensible
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;let命令、const命令、class命令声明的全局变量，不属于全局对象的属性
        &lt;ul&gt;
          &lt;li&gt;ES5之中，全局对象的属性与全局变量是等价的。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实例&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  const PI = 3.1415926;
  PI = 123;  // Uncaught TypeError: Assignment to constant variable
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;参考文章&quot;&gt;参考文章&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://m.cnblogs.com/57731/1551270.html?full=1&quot;&gt;变量作用域&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/?search=generator&amp;amp;x=0&amp;amp;y=0#docs/let&quot;&gt;ES6入门&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/ES6-let/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/ES6-let/</guid>
        
        <category>ES6</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>ES6-Module学习</title>
        <description>&lt;h1 id=&quot;module&quot;&gt;Module&lt;/h1&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ES6的Class只是面向对象编程的语法糖，升级了ES5构造函数原型继承的写法，并没有解决模块化的问题。&lt;/li&gt;
  &lt;li&gt;Js一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单方法拼装起来，因此对开发大型的、复杂项目形成障碍。&lt;/li&gt;
  &lt;li&gt;es6之前，模块化加载方案，主要有COmmonJS(用于服务器)和AMD(用于浏览器)两种.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;产生&quot;&gt;产生&lt;/h2&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;运行时加载: 整体加载一个模块(即加载所有方法)，生成一个对象，然后从对象上读取方法。&lt;/li&gt;
  &lt;li&gt;编译时加载: 从模块中加载需要使用的方法，其它方法都不加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;与传统模块化方法的区别&quot;&gt;与传统模块化方法的区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;es6实现的模块功能完全取代了现有的COmmonJS和AMD,成为通用的模块解决方案。&lt;/li&gt;
  &lt;li&gt;es6设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而CommonJS和AMD只能在运行的时候确定。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;es6模块不是对象，而是通过export命令显示指定输出的代码，输入时也采用静态命令的形式。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // ES6模块,实质是从fs模块加载3个方法，其他方法不加载
  import { stat, exists, readFile } from 'fs';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;es6在编译时完成模块加载，效率比CommonJS模块的加载方式高，这也导致无法引用ES6模块本身那个，因为它不是对象。&lt;/li&gt;
  &lt;li&gt;es6在编译时加载，使得静态分析成为可能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;模块的优点&quot;&gt;模块的优点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;静态加载；&lt;/li&gt;
  &lt;li&gt;不再需要UMD模块格式(将来浏览器都会支持ES6模块格式)&lt;/li&gt;
  &lt;li&gt;将来浏览器的新API就能用模块格式提供，不必再做成全局变量或navigator对象的属性&lt;/li&gt;
  &lt;li&gt;不再需要对象作为命名空间(比如Math对象)，未来这些功能可以通过模块提供&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;浏览器使用es6模块的语法: &lt;script type=&quot;module&quot; src=&quot;XX.js&quot;&gt;&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;由于type属性为module， 所以浏览器知道这是一个es6模块。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块，因此只能用babel这样的转码器在Node中使用ES6模块。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;特性&quot;&gt;特性&lt;/h2&gt;
&lt;h3 id=&quot;严格模式&quot;&gt;严格模式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ES6模块自动采用严格模式，不管头部有没有加’use strict’&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://xgfe.github.io/Basics/JavaScript/strictMode.html&quot;&gt;严格模式主要限制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;export命令&quot;&gt;export命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;模块功能主要由两个命令构成:export和import。
    &lt;ul&gt;
      &lt;li&gt;export命令用于规定模块的对外接口。&lt;/li&gt;
      &lt;li&gt;import命令用于输入其他模块提供的功能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;export&quot;&gt;export&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;作用:一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。&lt;/li&gt;
  &lt;li&gt;使用
    &lt;ul&gt;
      &lt;li&gt;使用大括号指定所要输出的一组变量
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 方法一:直接export
  export var firstName = 'Michael';
  export var lastName = 'Jackson';
  export var year = 1958;
        
  // 方法二: 使用{}export
  var firstName = 'Michael';
  var lastName = 'Jackson';
  var year = 1958;
  export {firstName, lastName, year};
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;export除了输出变量，还可以输出函数或类
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 对外输出了multiply
  export function multiply(x, y) {
    return x * y;
  };
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;一般情况下export输出的变量就是本来的名字，但可以使用as关键字重命名，并且重命名后可以使用不同的名字输出两次。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function v1() { ... }
  function v2() { ... }
  export {
    v1 as streamV1,
    v2 as streamV2,
    v2 as streamLatestVersion
  };
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。
        &lt;ul&gt;
          &lt;li&gt;它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 报错
  export 1;	
  // 报错
  var m = 1;
  export m;
            
  // 正确写法
  // 写法一
  export var m = 1;
        
  // 写法二
  var m = 1;
  export {m};
            
  // 写法三
  var n = 1;
  export {n as m};
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export var foo = 'bar';
  setTimeout(() =&amp;gt; foo = 'baz', 500);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;export命令可以出现在模块的任何位置。如果处于块级作用域内就会报错，因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;import命令&quot;&gt;import命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;作用:使用export命令定义模块的对外接口后，其他JS文件可以通过import命令加载这个模块(文件)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import {firstName, lastName, year} from './profile';
  function setName(element) {
    element.textContent = firstName + ' ' + lastName;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;import的{}里面的变量名必须与被导入模块对外接口(export)的名称相同&lt;/li&gt;
      &lt;li&gt;如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import { lastName as surname } from './profile';
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;import命令具有提升效果，会提升到整个模块的头部，首先执行。&lt;/li&gt;
      &lt;li&gt;如果在一个模块中，先输入后输出同一个模块，import语句可以与export语句写在一起.但从可读性考虑，不建议这种写法。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export { es6 as default } from './someModule';
  // 等同于
  import { es6 } from './someModule';
  export default es6;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;模块的整体加载&quot;&gt;模块的整体加载&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;除了指定加载某个输出值，可以使用整体加载，即用星号(*)指定一个对象，所有输出值都加载在这个对象上面
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // file1.js,导出方法
  export function area(radius) {
    return Math.PI * radius * radius;
  }
  export function circumference(radius) {
    return 2 * Math.PI * radius;
  }
  // file2.js,加载方法
  // 指定加载
  import { area, circumference } from './circle';
  console.log('圆面积：' + area(4));
  console.log('圆周长：' + circumference(14));
  // 整体加载
  import * as circle from './circle';
  console.log('圆面积：' + circle.area(4));
  console.log('圆周长：' + circle.circumference(14));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;export-default命令&quot;&gt;export default命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;以上内容使用inport命令的时候，用户需要知道所有加载的变量名或函数名，否则无法加载。&lt;/li&gt;
  &lt;li&gt;export default命令为模块指定默认输出，不用阅读文档就能加载模块;其他模块加载时,import命令可为该匿名函数指定任意名字。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 默认输出一个函数
  export default function(){
      console.log('default export');
  }
  // 加载默认export文件
  import customName from './export-default';
  customName(); // 'foo'
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export default命令用在非匿名函数前，也是可以的。&lt;/li&gt;
  &lt;li&gt;export * 命令会忽略导入模块中通过export default导出内容&lt;/li&gt;
  &lt;li&gt;使用default，注意import后面不要使用{}。即使用export default时，对应的import语句不需要使用大括号；不使用export default时，对应的import语句需要使用大括号。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 输出
  export default function defaultFn() {
    // ...
  }
  // 输入
  import defaultFn from 'defaultFn';
    
  // 输出
  export function defaultFn() {
    // ...
  };
  // 输入
  import {defaultFn} from 'defaultFn';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export default命令用于指定模块的默认输出，一个模块只能有一个默认输出。&lt;/li&gt;
  &lt;li&gt;本质上export default是输出一个叫做default的变量或方法，然后系统允许可以取任意名字
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function add(x, y) {
    return x * y;
  }
  export {add as default};  // 等同于  export default add;
    
  // app.js
  import { default as xxx } from 'modules'; // 等同于 import xxx from 'modules';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export default命令其事输出一个default的变量，因此其后不能跟变量声明语句
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 正确
  export var a = 1;
  // 正确
  var a = 1;
  export default a;
  // 错误
  export default var a = 1;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;一条import语句中，可以同时输入默认方法和其他变量
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import customName, { otherMethod } from './export-default';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;如果要输出默认的值，只需将值跟在export default之后即可
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export default 42;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export default也可以用来输出类
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // MyClass.js
  export default class { ... }
  // main.js
  import MyClass from 'MyClass';
  let o = new MyClass();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;模块的继承&quot;&gt;模块的继承&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;模块之间也可以继承
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // circleplus.js(假设circleplus模块继承circle模块)
  // 方法一
  export * from 'circle';  // 输出继承来的所有circle模块的属性和方法，忽略default方法
  export var e = 2.71828182846;
  export default function(x) {
    return Math.exp(x);
  }
  // 方法二
  export { area as circleArea } from 'circle'; // 将circle的属性或方法改名后再输出
    
  // 加载上面circleplus模块
  // main.js
  import * as math from 'circleplus';  // 加载所有属性和方法
  import exp from 'circleplus';  // 加载默认方法为exp
  console.log(exp(math.e));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;es6模块加载的实质&quot;&gt;ES6模块加载的实质&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用&lt;/li&gt;
  &lt;li&gt;CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。&lt;/li&gt;
  &lt;li&gt;ES6模块的运行机制是遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值。&lt;/li&gt;
  &lt;li&gt;ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // lib.js
  export let counter = 3;
  export function incCounter() {
    counter++;
  }
  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 3
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;以上test模块加载后，它的内部变化就影响不到输出的counter了。这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // lib.js
  var counter = 3; 		function incCounter() {     		counter++; 		} 		module.exports = {     		get counter() {         		return counter     		},     		incCounter: incCounter 		}
  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 实例一
  // lib.js
  export let counter = 3; 	export function incCounter() { 		counter++; 	}
  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4

  // 实例二
  // m1.js
  export var foo = 'bar';
  setTimeout(() =&amp;gt; foo = 'baz', 500);
  // m2.js
  import {foo} from './m1.js';
  console.log(foo);
  setTimeout(() =&amp;gt; console.log(foo), 500);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // lib.js
  export let obj = {};
  // main.js
  import { obj } from './lib';
  obj.prop = 123; // OK
  obj = {}; // TypeError:babel-compile都不会通过
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // mod.js
  function C() {
    this.sum = 0;
    this.add = function () {
      this.sum += 1;
    };
    this.show = function () {
      console.log(this.sum);
    };
  }
  export let c = new C();
  // x.js
  import {c} from './mod';
  c.add();	
  // y.js
  import {c} from './mod';
  c.show();
  // main.js
  import './x';
  import './y';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;循环加载&quot;&gt;循环加载&lt;/h3&gt;

&lt;p&gt;“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。&lt;/p&gt;

&lt;p&gt;“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。
 目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。&lt;/p&gt;

&lt;h4 id=&quot;commonjs模块的加载原理&quot;&gt;CommonJS模块的加载原理&lt;/h4&gt;
&lt;p&gt;CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。之后即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // Node内部加载模块后生成的一个对象
 {
      id: '...',   // 加载模块名
      exports: { ... },  // 模块输出的各个接口
      loaded: true,  // 布尔值，表示该模块的脚本是否执行完毕
      ...
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;commonjs模块的循环加载&quot;&gt;CommonJS模块的循环加载&lt;/h4&gt;
&lt;p&gt;CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，未执行的部分不会输出。
    ````
    // a.js
    console.log(‘a starting’);
    exports.done = false;
    const b = require(‘./b.js’);
    console.log(‘in a, b.done = %j’, b.done);
    exports.done = true;
    console.log(‘a done’);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//b.js
console.log('b starting');
exports.done = false;
const a = require('./a.js');  //此时只执行a.js的第一行，发生循环加载，系统会去a.js模块对应对象的exports取值，但还没执行完，因此只能取部分值(一旦require就会生成对象，然后一步步执行，同时往对象加值)。
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');

// main.js
console.log('main starting');
const a = require('./a.js');
const b = require('./b.js');  // 已经加载，只会从缓存中取值
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);

// 执行结果
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
``` - 备注
- 由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;es6模块的循环加载&quot;&gt;ES6模块的循环加载&lt;/h4&gt;

&lt;p&gt;ES6模块是动态引用，如果使用import从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // a.js如下
    import {bar} from './b.js';  //加载b，所以先执行b.js
    console.log('a.js');  // 加载a，但是a已经在执行了，所以不会重复执行，因此继续往下执行b.js
    console.log(bar);
    export let foo = 'foo';
    
    // b.js
    import {foo} from './a.js';
    console.log('b.js');
    console.log(foo);
    export let bar = 'bar';
    
    // 执行结果
    b.js
    undefined
    a.js
    bar
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;考考你&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // a.js
  import {bar} from './b.js';  // 建立引用，从b.js引用‘bar’
  export function foo() {
    console.log('foo');
    bar();  // 到b.js执行bar
    console.log('执行完毕');
  }
  foo();  // 执行时，引用都已完全建立
    
  // b.js
  import {foo} from './a.js';  // 建立引用，从a.js引用foo
  export function bar() {
    console.log('bar');
    if (Math.random() &amp;gt; 0.5) { // 递归执行foo，一旦随机数小于等于0.5就停止执行
      foo();
    }
  }
    
  // 执行结果
  // Math.random() &amp;lt;= 0.5
  foo
  bar
  执行完毕
    
  // Math.random() &amp;gt; 0.5
  foo
  bar
  foo
  bar
  执行完毕
  执行完毕
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md&quot;&gt;如何测试例子&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;跨模块常量&quot;&gt;跨模块常量&lt;/h3&gt;

&lt;p&gt;const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），可讲常量设置为一个单独的模块，可用以下代码实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from './constants';
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import {A, B} from './constants';
console.log(A); // 1
console.log(B); // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;es6模块的转码&quot;&gt;ES6模块的转码&lt;/h3&gt;
&lt;p&gt;浏览器目前还不支持ES6模块，现在要使用需要将其转换为ES5写法，有三种方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用Babel&lt;/li&gt;
  &lt;li&gt;ES6 module transpiler
    &lt;ul&gt;
      &lt;li&gt;定义:square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。&lt;/li&gt;
      &lt;li&gt;使用
        &lt;ul&gt;
          &lt;li&gt;安装这个转码器:  npm install -g es6-module-transpiler&lt;/li&gt;
          &lt;li&gt;文件转码: 使用compile-modules convert命令转码，-o参数可以指定转码后文件名
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   // 其中file1.js和file2.js是需要转换的es6文件
   compile-modules convert file1.js file2.js 
   // -o指定转码后的文件名，如果不指定，则默认在命令行输出转换后代码。out1.js如果不存在则会自动生成
   $ compile-modules convert file1.js file2.js -o out1.js out2.js
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SystemJS
    &lt;ul&gt;
      &lt;li&gt;定义: 它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google的Traceur转码器。&lt;/li&gt;
      &lt;li&gt;使用
        &lt;ul&gt;
          &lt;li&gt;首先在网页内载入system.js文件&lt;/li&gt;
          &lt;li&gt;接着使用System.import方法加载模块文件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;System.import使用异步加载，返回一个Promise对象，可以针对这个对象编程&lt;/li&gt;
          &lt;li&gt;在使用System.import之前需要在页面引入Google的Traceur转码器&lt;/li&gt;
          &lt;li&gt;加载的时候js文件要有后缀&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;阅读书籍&quot;&gt;阅读书籍&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://web.jobbole.com/82238/&quot;&gt;UMD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ModuleLoader/es6-module-loader/issues/95&quot;&gt;script type=module&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_cycles&quot;&gt;Node官方加载文档-使用CommonJs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md&quot;&gt;Es6-symbol加载-使用Module&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/esnext/es6-module-transpiler&quot;&gt;module-transpiler&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.gaoqixhb.com/p/55783789cef7e0a008d5d6ef&quot;&gt;Google Traceur&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/module&quot;&gt;Module&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/ES6-Module/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/ES6-Module/</guid>
        
        <category>ES6</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>yeoman简介与npm发包</title>
        <description>&lt;h1 id=&quot;yeoman&quot;&gt;YEOMAN&lt;/h1&gt;
&lt;p&gt;yeoman脚手架工具
Generators: 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;yo&lt;/code&gt;命令来生成文件&lt;/p&gt;
&lt;h2 id=&quot;组织自己的generators&quot;&gt;组织自己的generators&lt;/h2&gt;
&lt;h3 id=&quot;设置为一个node-module&quot;&gt;设置为一个node module&lt;/h3&gt;
&lt;p&gt;generator的核心就是node模块&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个名为’generator-XX’的文件夹。
    &lt;ul&gt;
      &lt;li&gt;Yeoman会依旧依赖稳健系统查找可用的generators&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件中创建&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;文件
    &lt;ul&gt;
      &lt;li&gt;可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;npm init&lt;/code&gt;创建&lt;/li&gt;
      &lt;li&gt;name必须要有&lt;code class=&quot;highlighter-rouge&quot;&gt;generator-&lt;/code&gt;前缀&lt;/li&gt;
      &lt;li&gt;关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;keywords&lt;/code&gt;必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;yeoman-generator&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;必须确保使用最新版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;yeoman-generator&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save yeoman-generator&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件目录
    &lt;ul&gt;
      &lt;li&gt;可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt;&lt;a href=&quot;https://github.com/yeoman/generator-generator&quot;&gt;generator-generator&lt;/a&gt;该项目，参考其内容&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;扩展generator
    &lt;ul&gt;
      &lt;li&gt;扩展基础generator
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      var Generator = require('yeoman-generator');
      module.exports = class extends Geneator{};
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;覆盖constructor方法
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constructor(args, opts) {
   super(args, opts);
   this.option('babel');
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;添加自己的功能
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; module.exports = class extends Generator {
    // overwrite constructor
    constructor(args, opts) {
       super(args, opts);
       this.option('babel');
    }
	   
    method1() {
       this.log('method 1 just ran');
    }
	   
    method2() {
       this.log('method 2 just ran');
    }
 };
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;运行generator
    &lt;ul&gt;
      &lt;li&gt;本地开发generator，不能作为全局npm module使用&lt;/li&gt;
      &lt;li&gt;使用npm创建全局module,并且和本地的建立链接&lt;/li&gt;
      &lt;li&gt;文件根目录下，运行&lt;code class=&quot;highlighter-rouge&quot;&gt;npm link&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;运行此命令之前需要进行npm发包，发包过程如下&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;link成功之后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;yo name&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;踩坑&lt;/em&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yo name&lt;/code&gt;命令中一定要使用name,而创建自己的generator必须要以generator-为前缀，即文件名为&lt;code class=&quot;highlighter-rouge&quot;&gt;generator-name&lt;/code&gt;。则使用&lt;code class=&quot;highlighter-rouge&quot;&gt;yo name&lt;/code&gt;的时候，只使用后面的name&lt;/li&gt;
          &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;yo name&lt;/code&gt;之前，要保证yo和generator-name安装在同一目录下，如yo是全局安装，则generator-name也要是全局安装。&lt;em&gt;yo XXX 的时候，在yo里要执行require(‘generator-XXX’)，因此位置必须统一&lt;/em&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;npm发包&quot;&gt;npm发包&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;注册账号&lt;/li&gt;
  &lt;li&gt;添加package.json文件，发包
    &lt;ul&gt;
      &lt;li&gt;npm publish&lt;/li&gt;
      &lt;li&gt;踩坑: 因为使用了公司npm镜像，然后莫名一直安装失败，只有使用&lt;code class=&quot;highlighter-rouge&quot;&gt;npm config set registry https://registry.npmjs.org/&lt;/code&gt;之后，再进行&lt;code class=&quot;highlighter-rouge&quot;&gt;npm publish&lt;/code&gt;才能成功&lt;/li&gt;
      &lt;li&gt;心得: 一定要看log文件，比在网上查好得多！！&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 28 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/28/yeoman-npm/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/28/yeoman-npm/</guid>
        
        <category>yeoman</category>
        
        <category>npm</category>
        
        <category>学习</category>
        
        
      </item>
    
  </channel>
</rss>
