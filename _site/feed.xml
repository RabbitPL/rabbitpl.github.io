<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rabbit</title>
    <description>有点理性，有点感性，有点执着，有点懒散，有点认真，有点浪的一枚普通程序媛</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 16 Sep 2017 15:48:02 +0800</pubDate>
    <lastBuildDate>Sat, 16 Sep 2017 15:48:02 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>Location简介</title>
        <description>&lt;h1 id=&quot;location对象&quot;&gt;location对象&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;BOM对象之一，提供与当前窗口中加载的文档有关的信息，以及还提供一些导航功能。它一方面保存当前文档信息，另一方面将URL解析为可访问独立片段。它既是window对象属性又是document对象属性，即&lt;code class=&quot;highlighter-rouge&quot;&gt;window.location === document.location&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;对象属性&quot;&gt;对象属性&lt;/h2&gt;
&lt;p&gt;location对象实现了&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/URLUtils&quot;&gt;URLUtils&lt;/a&gt;属性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hash
    &lt;ul&gt;
      &lt;li&gt;定义: 返回URL中的hash(#号后面0或多个字符)，如果URL不包括hash，则返回空字符串。&lt;/li&gt;
      &lt;li&gt;例子: “#contents”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;host
    &lt;ul&gt;
      &lt;li&gt;定义: 返回服务器名称和端口(如果有)&lt;/li&gt;
      &lt;li&gt;例子: “www.meituan.com:80”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;protocol
    &lt;ul&gt;
      &lt;li&gt;定义: 返回页面所使用的协议，通常是’http:’或’https:’&lt;/li&gt;
      &lt;li&gt;例子: “http:”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;hostname
    &lt;ul&gt;
      &lt;li&gt;定义: 返回不带端口号的服务器名称&lt;/li&gt;
      &lt;li&gt;例子: “www.meituan.com”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;href
    &lt;ul&gt;
      &lt;li&gt;定义: 返回当前加载页面的完整URL。&lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;location对象的toString()方法也返回这个值。&lt;/li&gt;
          &lt;li&gt;返回编码后的地址。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;例子: “http://www.meituan.com/”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pathname
    &lt;ul&gt;
      &lt;li&gt;定义: 返回URL中的目录和(或)文件名,以’/’开头&lt;/li&gt;
      &lt;li&gt;例子: “/zh-CN/docs/Web/API/URLUtils”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;search
    &lt;ul&gt;
      &lt;li&gt;定义: 返回URL的查询字符串。该字符串以问号开头。&lt;/li&gt;
      &lt;li&gt;例子: “?q=javascript”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;port
    &lt;ul&gt;
      &lt;li&gt;定义: 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串。&lt;/li&gt;
      &lt;li&gt;例子: “8080”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;origin
    &lt;ul&gt;
      &lt;li&gt;定义: 返回URL的协议、服务器以及端口&lt;/li&gt;
      &lt;li&gt;例子: ‘http://www.meituan.com:8080’&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 查询字符串参数
function getQueryStringArgs(){
	// 获取去掉?的查询参数
	var qs = (location.search.length &amp;gt; 0 ? location.search.substring(1) : &quot;&quot;);
	var args = {}; //数据对象
	var items = qs.length &amp;gt; 0 ? qs.split('&amp;amp;') : [];
	for(var i = 0; i &amp;lt; items.length; i++){
		args[items[i].split('=')[0]] = decodeURIComponent(items[i].split('=')[1]);
		console.log(items[i].split('=')[0] + ':' + decodeURIComponent(items[i].split('=')[1]));
	}
	return args;
}


// URLSearchParams:keys(),values(),entries()
var paramsObj = new URLSearchParams(location.search);
paramsObj.toString();
for(var pair of paramsObj.entries()) {
	console.log(pair[0]+ ', '+ pair[1]);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;对象方法&quot;&gt;对象方法&lt;/h2&gt;
&lt;p&gt;location对象实现了&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/URLUtils&quot;&gt;URLUtils&lt;/a&gt;方法。除toString之外这些方法都用来改变浏览器位置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assign
    &lt;ul&gt;
      &lt;li&gt;定义: 加载URL的内容资源到这个Location对象所关联的对象上。&lt;/li&gt;
      &lt;li&gt;使用: location.assign(url)&lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;打开一个新URL并在浏览器里是记录中生成一条记录。&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;location.href='urlX'&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;window.location='urlX'&lt;/code&gt;会以url为’urlX’调用assign()方法。即&lt;code class=&quot;highlighter-rouge&quot;&gt;window.location='www.meituan.com'和location.href='www.meituan.com'&lt;/code&gt;效果相同&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;reload
    &lt;ul&gt;
      &lt;li&gt;定义: 重新加载来自当前URL的资源。&lt;/li&gt;
      &lt;li&gt;使用: reload(flag)&lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;其具有一个可选参数,类型为boolean,该参数为true时会从服务器加载数据进行刷新，参数为false时浏览器从缓存加载页面。&lt;/li&gt;
          &lt;li&gt;如果不传递参数，则页面会以最有效的方式重新加载(即如果页面自上次请求以来并没有改变过则从缓存重新加载)。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;replace
    &lt;ul&gt;
      &lt;li&gt;定义: 用给定的URL替换当前的资源。&lt;/li&gt;
      &lt;li&gt;使用: replace(url)&lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;替换的新页面不会保存在history中。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;toString: 返回一个字符串，包含整个URL。效果同location.href,但不能修改location的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ps&quot;&gt;PS&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;改变浏览器位置方法一般常用location.href&lt;/li&gt;
  &lt;li&gt;在IE8，FF1，Safari 2+，Opera 9+ 和Chrome中，修改hash会在浏览器的历史记录中生成一条新纪录。&lt;/li&gt;
  &lt;li&gt;修改location中的其他属性也会改变当前加载的页面。并且每次修改location属性(除hash外)页面都会以新URL重新加载。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安全设置如(CORS:跨域资源共享)可能会限制实际加载页面。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  location.hash = '#section1';
  location.search = '?q=javascript';
  location.hostname = 'www.meituan.com';
  location.pathname = 'mydir'; 	location.port = 8080;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;windowlocation与documentlocation&quot;&gt;window.location与document.location&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;定义: window.location和document.location是一个只读属性，返回一个location对象，包含文档当前地址的相关信息。但是可以赋值给window.location。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   window.location = 'http://www.meituan.com';   // location = 'http://www.meituan.com'; 
   alert(window.location); 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;语法: &lt;code class=&quot;highlighter-rouge&quot;&gt;var oldLocation = window.location;  window.location = newLocation&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;oldLocation是一个location对象，提供了当前文档URL的相关信息以及几个用来改变这个URL的方法。&lt;/li&gt;
      &lt;li&gt;newLocation可以是一个location对象，但通常是字符串，指定要跳转的URL地址。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Location&quot;&gt;location&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/10546125/&quot;&gt;JS高级程序设计&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/location/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/location/</guid>
        
        <category>JS</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>History简介</title>
        <description>&lt;h1 id=&quot;history对象&quot;&gt;History对象&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;浏览器窗口有一个history对象，用来保存浏览历史。history对象提供了一些列的方法和属性，允许在浏览器之间移动。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;back(): 移动到上一个访问页面，等同于浏览器的后退键。
    &lt;ul&gt;
      &lt;li&gt;返回上一页时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;forward(): 移动到下一个访问页面，等同于浏览器的前进键。&lt;/li&gt;
  &lt;li&gt;go(): 接受一个整数作为参数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1)相当于back()。
    &lt;ul&gt;
      &lt;li&gt;history.go(0): 刷新当前页面&lt;/li&gt;
      &lt;li&gt;history.go(str): 可以接受一个字符串str,浏览器会跳转到历史记录中包含该字符串的第一个位置(可能前进，可能后退)，具体要看哪个位置最近，如果历史记录中不包含该字符串，则该方法什么都不做
        &lt;ul&gt;
          &lt;li&gt;参考资料:https://msdn.microsoft.com/en-us/library/ms536443(v=vs.85).aspx&lt;/li&gt;
          &lt;li&gt;历史纪录指的就是url，&lt;strong&gt;不能跨域&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;length: 保存历史记录的数量，这数量包含所有历史记录。
    &lt;ul&gt;
      &lt;li&gt;对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0&lt;/li&gt;
      &lt;li&gt;Internet Explorer和Opera从0开始，而Firefox、Chrome和Safari从1开始。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;注意点&quot;&gt;注意点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;如果移动的位置超出了访问历史的边界，back,forward,go三个方法并不报错，而是默默的失败&lt;/li&gt;
  &lt;li&gt;当页面的URL改变时,就会生成一条历史记录。在IE8及更高版本、Opera、Firefox、Safari3及更高版本及Chrome中，这里所有的改变包括URL中的hash的变化.因此，设置location.hash会在这些浏览器中生成一条新的历史记录&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果窗口包涵多个子窗口，子窗口的浏览历史会按时间顺序穿插在主窗口的历史中&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;form name=&quot;form1&quot; id=&quot;form1&quot;&amp;gt;
          &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;/&amp;gt;
          &amp;lt;button onclick=&quot;clickFn()&quot;&amp;gt;改变地址&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
      &amp;lt;iframe src=&quot;pjax.html&quot; width=100% style=&quot;margin-top: 100px;&quot; name=&quot;test&quot;&amp;gt;
      &amp;lt;/iframe&amp;gt;
      &amp;lt;script&amp;gt;
          var addr = ['https://www.baidu.com', &quot;http://www.meituan.com&quot;, &quot;http://www.taobao.com&quot;];
          var i = 0;
          function clickFn(){
            if( i &amp;gt; 2){
                i = 0;
            }
            window.frames['test'].location.href = addr[i];
            i++;
            document.getElementById('username').value = history.length;
          }
      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;html5中history的新方法&quot;&gt;HTML5中history的新方法&lt;/h2&gt;
&lt;p&gt;所有主流浏览器都支持这两种方法(包括IE10)。&lt;/p&gt;

&lt;p&gt;可以使用一下代码来检查当前浏览器是否支持History API&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (!!(window.history &amp;amp;&amp;amp; history.pushState)){
  // 支持History API
} else {
  // 不支持
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;historypushstate&quot;&gt;history.pushState()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;定义: 用来在浏览历史中逐条添加纪录&lt;/li&gt;
  &lt;li&gt;参数介绍
    &lt;ul&gt;
      &lt;li&gt;state(状态对象): 与指定网址相关的状态对象，popstate事件触发时(用户导航到新建的状态)，该对象会传入回调函数。如果不需要这个对象，此处可以填null。&lt;/li&gt;
      &lt;li&gt;title: 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。&lt;/li&gt;
      &lt;li&gt;url: 新的历史记录条目的网址。浏览器的地址栏将显示这个网址。但是调用pushState方法之后不会刷新页面。该参数可选，不指定的话则为文档当前URL。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;任何可序列化的对象都可以被当做状态对象。FireFox浏览器会把状态对象保存到用户的硬盘，用户重启浏览器之后会被还原，因此强行限制状态对象的大小为640k。如果传入pushState()方的状态对象超标，则该方法会抛出异常。如果需要存储很大的数据，建议使用sessionStorage或localStorage。&lt;/li&gt;
      &lt;li&gt;新的URL不一定是绝对路径，如果是相对路径，则以当前URL为基准，因此传入的URL与当前URL应该是同源的，否则pushState会抛出异常。&lt;/li&gt;
      &lt;li&gt;pushState()方法永远不会触发hashchange事件，即便新的地址只变更了hash.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;与window.location的不同
    &lt;ul&gt;
      &lt;li&gt;新URL可以是任意的同源URL，而window.location只有仅修改hash才能保证停留在相同的document中。&lt;/li&gt;
      &lt;li&gt;根据个人需要确定是否修改URL。相反，设置window.location=”#foo”，只有在当前hash值不是foo时才创建一条新历史记录。&lt;/li&gt;
      &lt;li&gt;可以在新的历史记录条目中添加抽象数据.如果使用基于hash的方法，只能把相关数据转码成一个很短的字符串。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;windowonpopstate&quot;&gt;window.onpopstate&lt;/h3&gt;
&lt;p&gt;window.onpopstate是popstate事件在window对象上的事件句柄。当前活动历史项改变会触发popstate事件。调用history.pushState()创建新历史项，或调用history.replaceState()替换新的历史项,那么popstate事件的state属性会包含历史项状态对象(state)的拷贝。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;调用history.pushState()和history.replaceState()不会触发popstate事件，只有在浏览器操作时会触发该事件，如用户点击回退和前进按钮，或通过js调用history.back()函数。&lt;/li&gt;
      &lt;li&gt;不同浏览器在加载页面时处理popstate事件的形式存在差异。页面加载时Chrome和Safari通常会触发popstate事件(低版本)，但是Firefox和IE浏览器不会。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实例&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onpopstate = function(event) {
   alert(&quot;location: &quot; + document.location + &quot;, state: &quot; + 	JSON.stringify(event.state));
};
history.pushState({page: 1}, &quot;title 1&quot;, &quot;?page=1&quot;);
history.pushState({page: 2}, &quot;title 2&quot;, &quot;?page=2&quot;);
history.pushState({page: 3}, &quot;title 3&quot;, &quot;?page=3&quot;);
history.replaceState({page: 4}, &quot;title 3&quot;, &quot;?page=4&quot;);
history.back();
history.back(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;historyreplacestate&quot;&gt;history.replaceState()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;定义: 用来在浏览历史中修改纪录.操作类似pushState()&lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;当更新当前历史记录条目的状态对象或URL时，使用replaceState()方法特别合适&lt;/li&gt;
      &lt;li&gt;替换的是当前历史对象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;historystate属性&quot;&gt;history.state属性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;定义:history.state属性保存当前页面的state对象。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实例&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  history.pushState({page: 1}, &quot;title 1&quot;, &quot;?page=1&quot;);
  history.state
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;页面加载时，可能包含一个非空状态对象。例如,如果页面中使用pushState或replaceState方法设置了一个状态对象，然后用户重启浏览器。&lt;/li&gt;
      &lt;li&gt;页面重新加载会触发onload事件，但是不会触发popstate事件，通过history.state属性可以获取一个与popstate事件触发时得到一样的状态对象。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;备注&quot;&gt;备注&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;仅仅调用pushState方法或replaceState方法 ，并不会触发window.onpopstate事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用JavaScript调用back、forward、go方法时才会触发。&lt;/li&gt;
  &lt;li&gt;window.onpopstate事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。&lt;/li&gt;
  &lt;li&gt;使用的时候，可以为popstate事件指定回调函数。这个回调函数的参数是一个event事件对象，它的state属性指向pushState和replaceState方法为当前url所提供的状态对象&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onpopstate = function(event) {
  console.log(&quot;location: &quot; + document.location);
  console.log(&quot;state: &quot; + JSON.stringify(event.state));
};
// 或者
window.addEventListener('popstate', function(event) {  
  console.log(&quot;location: &quot; + document.location);
  console.log(&quot;state: &quot; + JSON.stringify(event.state));  
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;当页面第一次加载的时候，在onload事件发生后，Firefox和IE浏览器不会以及大多数(最新版本)Safari和Chrome浏览器都不会触发window.onpopstate事件。iphone手机8.4.1版本打开浏览器会触发window.onpopstate事件，而9.3.5版本则已经无法触发。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;urlsearchparams-api&quot;&gt;URLSearchParams API&lt;/h2&gt;
&lt;p&gt;URLSearchParams API用于处理URL之中的查询字符串，即问号之后的部分。&lt;/p&gt;

&lt;h3 id=&quot;用来操作某个参数的方法&quot;&gt;用来操作某个参数的方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;has(): 返回一个布尔值，表示是否具有某个参数&lt;/li&gt;
  &lt;li&gt;get(): 返回指定参数的第一个值&lt;/li&gt;
  &lt;li&gt;getAll(): 返回一个数组，成员是指定参数的所有值&lt;/li&gt;
  &lt;li&gt;set(): 设置指定参数&lt;/li&gt;
  &lt;li&gt;delete(): 删除指定参数&lt;/li&gt;
  &lt;li&gt;append(): 在查询字符串之中，追加一个键值对&lt;/li&gt;
  &lt;li&gt;toString(): 返回整个查询字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var paramsString = &quot;q=URLUtils.searchParams&amp;amp;topic=api&quot;
var searchParams = new URLSearchParams(paramsString);
console.log(searchParams.has('topic')); // true
console.log(searchParams.get('topic')); // &quot;api&quot;
console.log(searchParams.getAll('topic')); // [&quot;api&quot;]
console.log(searchParams.get('foo'));  // null
searchParams.set('foo', 2);
console.log(searchParams.get('foo')); // 2
searchParams.append('topic', 'webdev');
console.log(searchParams.toString()); //&quot;q=URLUtils.searchParams&amp;amp;topic=api&amp;amp;foo=2&amp;amp;topic=webdev&quot;
searchParams.append('foo', 3);
console.log(searchParams.getAll('foo')); // [2, 3]
searchParams.delete('topic');
console.log(searchParams.toString()); // &quot;q=URLUtils.searchParams&amp;amp;foo=2&amp;amp;foo=3&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;用来遍历所有参数的方法&quot;&gt;用来遍历所有参数的方法&lt;/h3&gt;
&lt;p&gt;以下三个函数，返回的都是Iterator对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;keys(): 遍历所有参数名&lt;/li&gt;
  &lt;li&gt;values(): 遍历所有参数值&lt;/li&gt;
  &lt;li&gt;entries(): 遍历所有参数的键值对
    &lt;ul&gt;
      &lt;li&gt;在Chrome浏览器之中，URLSearchParams实例本身就是Iterator对象，与entries方法返回值相同.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(var key of searchParams.keys()) {
  console.log(key);   // q; foo; foo
}
for(var value of searchParams.values()) {
  console.log(value);  // URLUtils.searchParams;  2;  3
}
for(var pair of searchParams.entries()) {
  console.log(pair[0]+ ', '+ pair[1]);  // q, URLUtils.searchParams; foo, 2; foo, 2
}
// URLSearchParams实例本身就是Iterator对象
for (var p of searchParams) {
  console.log(p);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;实例&quot;&gt;实例&lt;/h2&gt;
&lt;h3 id=&quot;pjaxpushstate--ajax&quot;&gt;pjax(pushState + ajax)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;基本思路
    &lt;ul&gt;
      &lt;li&gt;链接(点击)–&amp;gt;ajax刷新数据+使用pushState改变url&lt;/li&gt;
      &lt;li&gt;popstate事件–&amp;gt;刷新数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ngrouter&quot;&gt;ngRouter&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$browser.onUrlChange(callback) --&amp;gt; $locationChangeStart --&amp;gt; $routeChangeStart --&amp;gt; 动态编译模版插入&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;项目中使用ng-router,使用的pushState动态改变url，因此前进或后退操作不会造成页面加载&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xing901022/p/5154358.html&quot;&gt;Angular路由&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Events/popstate&quot;&gt;popstate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/DOM/Manipulating_the_browser_history&quot;&gt;HTML5中history对象&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://javascript.ruanyifeng.com/bom/history.html&quot;&gt;URLSearchParams&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/&quot;&gt;PJAX&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/welefen/pjax&quot;&gt;pjax&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://caniuse.com/#search=pushstate&quot;&gt;浏览器支持情况&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/history/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/history/</guid>
        
        <category>JS</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>编写高质量的JS代码</title>
        <description>&lt;h1 id=&quot;编写高质量js代码&quot;&gt;编写高质量JS代码&lt;/h1&gt;
&lt;h1 id=&quot;目录&quot;&gt;目录&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;让自己习惯JavaScript&lt;/li&gt;
  &lt;li&gt;变量作用域&lt;/li&gt;
  &lt;li&gt;使用函数&lt;/li&gt;
  &lt;li&gt;对象和原型&lt;/li&gt;
  &lt;li&gt;数组和字典&lt;/li&gt;
  &lt;li&gt;库和API设计&lt;/li&gt;
  &lt;li&gt;并发&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;内容详解&quot;&gt;内容详解&lt;/h1&gt;
&lt;h2 id=&quot;让自己习惯javascript&quot;&gt;让自己习惯JavaScript&lt;/h2&gt;
&lt;h3 id=&quot;了解你使用的js版本&quot;&gt;了解你使用的js版本&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;决定你的应用程序支持JS的哪些版本&lt;/li&gt;
  &lt;li&gt;确保你使用的任何JS的特性对于应用程序将要运行的所有环境都是支持的&lt;/li&gt;
  &lt;li&gt;总是要在执行严格模式检查的环境中测试严格代码&lt;/li&gt;
  &lt;li&gt;当心连接那些在不同严格模式下有不同预期的脚本
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://xgfe.github.io/Basics/JavaScript/strictMode.html&quot;&gt;严格模式注意点&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;‘use strict’指令只有在脚本或函数的顶部才能生效
        &lt;ul&gt;
          &lt;li&gt;在开发中使用多个独立的文件，但是部署到产品环境时却需要连接成一个单一的文件。
            &lt;ul&gt;
              &lt;li&gt;不要将进行严格模式检查的文件和不进行严格模式检查的文件连接在一起。&lt;/li&gt;
              &lt;li&gt;通过将其自身包裹在理解调用的函数表达式(IIFE)中的方式连接多个文件&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;理解javascript的浮点数&quot;&gt;理解JavaScript的浮点数&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Javascript的数字都是双精度的浮点数&lt;/li&gt;
  &lt;li&gt;Javascript中的整数仅仅是双精度浮点数的一个子集，而不是一个单独的数据类型&lt;/li&gt;
  &lt;li&gt;位运算符将数字视为32位的有符号整数
    &lt;ul&gt;
      &lt;li&gt;它们将操作数转换为整数，然后使用整数位模式(被隐式的转换成32位大端的2的补码表示的整数)进行运算， 最后将结果转换为标准的Js浮点数&lt;code class=&quot;highlighter-rouge&quot;&gt;8 | 1 = 9&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当心浮点运算中的精度陷阱&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; (0.1 + 0.2) + 0.3;     // 0.6000000000000001
 0.1 + (0.2 + 0.3);     // 0.6
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;尽可能的采用整数数值运算，货币相关计算，通常会按比例将数值转换为最小的货币单位来进行计算，这样就可以以整数进行计算&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;当心隐式的强制转换&quot;&gt;当心隐式的强制转换&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;类型错误可能被隐式的强制转换所隐藏
    &lt;ul&gt;
      &lt;li&gt;算术运算符-、*、/、%在计算之前都会尝试将其参数转换为数字
        &lt;ul&gt;
          &lt;li&gt;null会被转换为0&lt;/li&gt;
          &lt;li&gt;未定义变量被转换为特殊的浮点数值NaN(JS中唯一一个不等于其自身的值)
            &lt;ul&gt;
              &lt;li&gt;检查一个值是否为NaN: &lt;code class=&quot;highlighter-rouge&quot;&gt;a!==a&lt;/code&gt;;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;重载的运算符+是进行加法运算还是字符串连接操作取决于其参数类型
    &lt;ul&gt;
      &lt;li&gt;数字和字符串一起，会将数字转换为字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;1+2+'3' = 33&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对象通过valueOf方法强制转换为数字，通过toString方法强制转换为字符串
    &lt;ul&gt;
      &lt;li&gt;对象的运算符+被重载时，JS选择valueOf方法进行转换&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var obj = {
     toString: function(){
         return '[object MyObject]';
     },
     valueOf: function(){
         return 17;
     }
 }
 'object:' + obj;  // &quot;object:17&quot;
 1 + obj;  // 18
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;具有valueOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字的字符串表示&lt;/li&gt;
  &lt;li&gt;测试一个值是否为未定义的值，应该使用typeof或者与undefined进行比较而不是使用真值运算
    &lt;ul&gt;
      &lt;li&gt;Js中7个假值: false、0、－0、”“、NaN、null、undefined&lt;/li&gt;
      &lt;li&gt;检查参数是否为undefined
        &lt;ul&gt;
          &lt;li&gt;使用typeof:&lt;code class=&quot;highlighter-rouge&quot;&gt;typeof a&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;与undefined进行比较&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;原始类型优于封装对象&quot;&gt;原始类型优于封装对象&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;当做相等比较时，原始类型的封装对象与其原始值行为不一样
    &lt;ul&gt;
      &lt;li&gt;JS有5个原始值类型: 布尔值、数字、字符串、null和undefined
        &lt;ul&gt;
          &lt;li&gt;对null进行typeof是object&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;获取和设置原始类型值的属性会隐式地创建封装对象
    &lt;ul&gt;
      &lt;li&gt;当对原始值提取属性和进行方法调用时，它表现得就像已经使用了对应的对象类型封装了该值一样。&lt;/li&gt;
      &lt;li&gt;隐式封装可以对原始值设置属性，但是对其丝毫没有影响&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 'hello'.name = 'my name is hello';
 'hello'.name
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免对混合类型使用运算符&quot;&gt;避免对混合类型使用==运算符&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;1.0e0&quot; == {valueOf: function(){ return true; }};  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;当参数类型不同时，==运算符应用了一套难以理解的隐式强制转换规则。
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;当两个参数属于同一类时，==和===运算符的行为是没有区别的&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;运算符的强制转换规则&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数类型1&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;参数类型2&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;强制转换&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;null&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;不转换，返回true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;null或undefined&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;其他任何非null或undefined的类型&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;不转换总是返回false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型:string,number或boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Date对象&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;将原始类型转换为数字，将Date对象转换为原始类型(优先调用toString，再尝试valueOf)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型:string,number或boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;非Date对象&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;将原始类型转换为数字，将非Date对象转换为原始类型(优先调用valueOf，再尝试toString)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原始类型:string,number或boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;原始类型:string,number或boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;将原始类型转换为数字&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;使用===运算符，使读者不需要涉及任何的隐式强制转换就能明白你的比较运算&lt;/li&gt;
  &lt;li&gt;当比较不同类型的值时，使用你自己的显示强制转换使程序的行为更清晰&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;了解分号插入的局限&quot;&gt;了解分号插入的局限&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;分号插入规则
    &lt;ul&gt;
      &lt;li&gt;分号仅在}标记之前、一个或多个换行之后和程序输入的结尾被插入；&lt;/li&gt;
      &lt;li&gt;分号仅在随后的输入标记不能解析时插入;&lt;/li&gt;
      &lt;li&gt;分号不会做为分隔符在for循环空语句的头部被自动插入&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在以(、[、+、-、或/字符开头的语句前绝不能省略分号;&lt;/li&gt;
  &lt;li&gt;当脚本连接的时候，在脚本之间显示地插入分号;&lt;/li&gt;
  &lt;li&gt;在return、throw、break、continue、++、–的参数之前绝不能换行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;视字符串为16位的代码单元序列&quot;&gt;视字符串为16位的代码单元序列&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;JavaScript字符串由16位的代码单元组成，而不是由Unicode代码点组成
    &lt;ul&gt;
      &lt;li&gt;Unicode编码标准:UTF-8、UTF-16、UTF-32&lt;/li&gt;
      &lt;li&gt;JavaScript允许直接用码点表示Unicode字符，写法是”反斜杠+u+码点”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JavaScript使用两个代码单元表示2^16及其以上的Unicode代码点。这两个代码单元被称为代理对
    &lt;ul&gt;
      &lt;li&gt;字符串的属性和方法(length、charAt、charCodeAt)都是基于代码单元层级&lt;/li&gt;
      &lt;li&gt;一个JS字符串的元素是一个16位的代码单元&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;代理对甩开了字符串元素计数，length、charAt、charCodeAt方法以及正则表达式模式(例如’.’)受到影响&lt;/li&gt;
  &lt;li&gt;使用第三方的库编写可识别代码点的字符串操作&lt;/li&gt;
  &lt;li&gt;每当你使用一个含有字符串操作的库时，你都需要查阅该库文档，看它如何处理代码点的整个范围
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;\u221a&quot; === √
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;变量作用域&quot;&gt;变量作用域&lt;/h2&gt;
&lt;h3 id=&quot;尽量少用全局对象&quot;&gt;尽量少用全局对象&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;避免声明全局变量，尽量声明局部变量
    &lt;ul&gt;
      &lt;li&gt;全局变量会污染共享的公共命名空间，并可能导致意外的命名冲突&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;避免对全局对象添加属性
    &lt;ul&gt;
      &lt;li&gt;声明全局变量两种方法: 在全局作用域中使用var声明它；将其加入到全局对象中.&lt;/li&gt;
      &lt;li&gt;在web浏览器中，全局对象被绑定到全局的window变量:&lt;code class=&quot;highlighter-rouge&quot;&gt;foo == this.foo == window.foo&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用全局对象来做平台特性检测。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;始终声明局部变量&quot;&gt;始终声明局部变量&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function swap(a, i, j){
	temp = a[i];  // global
	a[i] = a[j];
	a[j] = temp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;始终是用var声明新的局部变量&lt;/li&gt;
  &lt;li&gt;考虑使用lint工具帮助检查未绑定的变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;避免使用with&quot;&gt;避免使用with&lt;/h3&gt;
&lt;h3 id=&quot;熟练掌握闭包&quot;&gt;熟练掌握闭包&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;理解闭包
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Js允许你引用在当前函数以外定义的变量&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;即使外部函数已返回，当前函数仍然可以引用在外部函数所定义的变量&lt;/li&gt;
      &lt;li&gt;闭包可以更新外部变量的值(闭包存储的是外部变量的引用，而不是它们的值的副本)
        &lt;ol&gt;
          &lt;li&gt;函数可以引用定义在其外部作用域的变量&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function makeSandwich(){
      var magicIngredient = 'peanut butter';
      function make(filling){
          return magicIngredient + &quot; and &quot; + filling;
      }
      return make('jelly');
  }
  makeSandwich(); // &quot;peanut butter and jelly&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  2. 闭包比创建它们的函数有更长的生命周期   - Js函数值还在内部存储它们可能会引用的定义在其封闭作用域的变量，而那些在其所涵盖的作用域内跟踪变量的函数被称为闭包。   - 构建闭包的字面量语法－－函数表达式
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function makeSandwich(){
      return function (filling){
          return magicIngredient + &quot; and &quot; + filling;
      }
	}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  3. 闭包在内部存储其外部变量的引用，并能读写这些变量
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function  box(){
      var val = undefined;
      return {
          set: function(newVal){ val = newVal;},
          get: function(){ return val; },
          type: function(){ return typeof val;}
      };
  }
  var b = box();
  b.type(); //&quot;undefined&quot;
  b.set(98.6);
  b.get();  // 98.6
  b.type();  // &quot;number&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;理解变量声明提升&quot;&gt;理解变量声明提升&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在代码块中的变量声明会被隐式的提升到封闭函数的顶部
    &lt;ul&gt;
      &lt;li&gt;把声明看作由两部分组成，即声明和赋值。JS隐式地提升声明部分到封闭函数的顶部，而将赋值留在原地&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;重声明变量被视为单个变量
    &lt;ul&gt;
      &lt;li&gt;js没有块级作用域除了try…catch，try…catch将捕获的异常绑定到一个变量，该变量的作用域只是catch语句块。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function test(){
     var x = &quot;var&quot;, result = [];
     result.push(x);
     try{
         throw 'expection';
     } catch(x){
         x = 'catch';
     }
     result.push(x);
     return result;
 }
 test(); // [&quot;var&quot;, &quot;var&quot;]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;考虑手动提升局部变量的声明，从而避免混淆&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用立即调用的函数表达式创建局部作用域&quot;&gt;使用立即调用的函数表达式创建局部作用域&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;理解绑定与赋值的区别
    &lt;ul&gt;
      &lt;li&gt;运行时进入一个作用域，js会为每一个绑定到该作用域的变量在内存中分配一个‘槽(slot)’&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function wrapElements(a) {
     var result = [], i, n;  // 分配三个槽
     for(i = 0, n = a.length; i &amp;lt; n; i++){
        result[i] = function(){  // 闭包,a[i]存储的是引用,i共享一个槽
            return a[i];
        }
     }
     return result;
 }
 var wrapped = wrapElements([10, 20, 30, 40, 50]);
 var f = wrapped[0];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;闭包通过引用而不是值捕获它们的外部变量&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用立即调用函数表达式(IIFE)来创建局部作用域&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function wrapElements(a) {
     var result = [], i, n;
     for(i = 0, n = a.length; i &amp;lt; n; i++){
         (function(){
             var j = i;
             result[i] = function(){
                 return a[j];
             }
         })();
         /**
        (function(j){
             result[i] = function(){
                 return a[j];
             }
         })(i);
         **/
     }
     return result;
 }
 var wrapped = wrapElements([10, 20, 30, 40, 50]);
 var f = wrapped[0];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;当心在立即调用的函数表达式中包裹代码块可能改变其行为的情形。
    &lt;ul&gt;
      &lt;li&gt;代码块不能包含任何跳出块的break语句和continue语句&lt;/li&gt;
      &lt;li&gt;如果代码块引用了this或arguments变量，IIFE将会改变它们的含义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;当心命名函数表达式笨拙的作用域&quot;&gt;当心命名函数表达式笨拙的作用域&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在Error对象和调试器中使用命名函数表达式改进栈跟踪&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var f = function double(x){ return x*2; }
 // 此语句将该函数绑定到变量f而不是变量double
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;匿名和命名函数表达式区别: 后者会绑定到与其函数名相同的变量上，该变量将作为函数内的一个局部变量&lt;/li&gt;
      &lt;li&gt;在跟踪栈中，函数表达式的名称通常作为其入口使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在ES3和有问题的JS环境中谨记函数表达式作用域会被Object.prototype污染
    &lt;ul&gt;
      &lt;li&gt;在ES3中，JS引擎被要求将命名函数表达式的作用域表示为一个对象，该作用域对象继承了Object.prototype的属性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;谨记在错误百出的js环境中会提升命名函数表达式声明，并导致命名函数表达式的重复存储&lt;/li&gt;
  &lt;li&gt;考虑避免使用命名函数表达式或在发布前删除函数名&lt;/li&gt;
  &lt;li&gt;如果你将代码发布到正确实现的ES5环境中，那么你没有什么好担心的&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;当心局部块函数声明笨拙的作用域&quot;&gt;当心局部块函数声明笨拙的作用域&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为
    &lt;ul&gt;
      &lt;li&gt;始终避免将函数声明置于局部块或子语句中&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function f(){ return 'global'; }
 function test(x){
     var result = [];
     if(x){
         function f(){
             return 'local';
         }
         result.push(f());
     }
     result.push(f());
     return result;
 }
 test(true);
 test(false);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用var声明和有条件的赋值语句替代有条件的函数声明&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function f(){ return 'global'; }
 function test(x){
     var g = f;
     var result = [];
     if(x){
         g = function f(){
             return 'local';
         }
         result.push(g());
     }
     result.push(g());
     return result;
 }
 test(true);
 test(false);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免使用eval创建局部变量&quot;&gt;避免使用eval创建局部变量&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;避免使用eval函数创建的变量污染调用者的作用域&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function test(x){
     eval('var y = x;')
     return y;
 }
 test('hello'); // hello
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;间接调用eval函数优于直接调用&quot;&gt;间接调用eval函数优于直接调用&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;将eval函数同一个毫无意义的字面量包裹在序列表达式中以达到强制使用间接调用eval函数的目的
    &lt;ul&gt;
      &lt;li&gt;eval函数具有访问调用它那时的整个作用域的能力&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;函数调用涉及eval标识符,被认为是一种”直接”调用eval函数的方式&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 直接调用
  var x = 'global';
  function test(){
     var x = 'local';
     return eval('x');  // 'local'
  }
  test();
  // 间接调用
  var x = 'global';
  function test(){
     var x = 'local';
     var f = eval;
     return f('x');  // global
  }
  test();
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;绑定eval函数到另一个变量名，通过该变量名调用函数会使代码失去对所有局部作用域的访问能力&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;尽可能间接调用eval函数，而不要直接调用eval函数
    &lt;ul&gt;
      &lt;li&gt;编写间接调用eval函数的另一种简洁方式是使用表达式序列运算符(,)和一个明显毫无意义的数字字面量｀(0, eval)(src)｀&lt;/li&gt;
      &lt;li&gt;直接调用eval函数性能上的损耗是相当高昂的(需要承担直接调用eval函数导致其包含的函数以及所有直到函数最外层的函数运行相当缓慢的风险)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;使用函数&quot;&gt;使用函数&lt;/h2&gt;
&lt;h3 id=&quot;理解函数调用方法调用及构造函数调用之间的不同&quot;&gt;理解函数调用、方法调用及构造函数调用之间的不同&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JS中函数，方法，类的构造函数是单个构造对象的不同使用模式
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;函数调用&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function hello(userName){
  	return &quot;hello,&quot; + userName;
  }
  hello('pl');  // &quot;hello,pl&quot;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;方法调用:对象的属性恰好是函数&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var obj = {
  hello: function(){
      return 'hello,' + this.userName;
  },
  userName: 'pl'
  }
  obj.hello(); // &quot;hello,pl&quot;
  var obj2 = {
      hello: obj.hello,
      userName: 'rabbit'
  };
  obj2.hello();  // &quot;hello,rabbit&quot;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;ul&gt;
          &lt;li&gt;方法调用中是由调用表达式自身来确定this变量的绑定。绑定到this变量的对象被称为调用接收者&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;ES5的严格模式将this变量的默认值绑定值改为undefined&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function hello(){
      // 'use strict';
      console.log(this);
      return &quot;hello,&quot; + this.userName;
  }
  hello();
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通过构造函数使用&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;使用new操作符来调用函数，则视其为构造函数。构造函数调用将一个全新的对象作为this变量的值，并隐式返回这个新对象作为调用结果。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;熟练掌握高阶函数&quot;&gt;熟练掌握高阶函数&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;高阶函数是那些将函数作为参数或返回值的函数&lt;/li&gt;
  &lt;li&gt;熟练掌握现有库中的高阶函数
    &lt;ul&gt;
      &lt;li&gt;Array.prototype.sort、forEach、map、filter等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;学会发现可以被高阶函数所取代的常见的编码模式
    &lt;ul&gt;
      &lt;li&gt;需要引入高阶函数抽象的信号是出现重复或相似的代码&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 使用英文字母创建一些字符串
 var aIndex = &quot;a&quot;.charCodeAt(0);
 var alphabet = &quot;&quot;;
 for(var i = 0; i &amp;lt; 26; i++){
     alphabet += String.fromCharCode(aIndex + i);
 }
 alphabet; //&quot;abcdefghijklmnopqrstuvwxyz&quot;
 // 生成一个包含数字的字符串
 var digits = &quot;&quot;;
 for(var i = 0; i &amp;lt; 10; i++){
     digits += i;
 }
 digits;  // &quot;0123456789&quot;
 // 创建一个随机的字符串
 var aIndex = &quot;a&quot;.charCodeAt(0);
 var random = &quot;&quot;;
 for(var i=0; i&amp;lt;8; i++){
     random += String.fromCharCode(Math.floor(Math.random() * 26) + aIndex);
 }
 random;  //&quot;uraugvrx&quot;
 // 上面三种，都是创建一个字符串，只是创建的方式不同
 function buildString(n, callback){
     var result = &quot;&quot;;
     for(var i=0; i&amp;lt;n; i++){
         result = callback(i);
     }
     return result;
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用call方法自定义接收者来调用方法&quot;&gt;使用call方法自定义接收者来调用方法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用call方法自定义接收者来调用此函数
    &lt;ul&gt;
      &lt;li&gt;通常，函数或方法的接收者(即绑定到特殊关键字this的值)是由调用者的语法决定的。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; obj.temporary = f;
 var result = obj.temporary(arg1, arg2, arg3);
 delete obj.temporary;
 // 使用call
 f.call(obj, arg1, arg2, arg3);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;使用call方法可以调用在给定的对象中不存在的方法&lt;/li&gt;
  &lt;li&gt;使用call方法定义高阶函数允许使用者给回调函数指定接收者&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用apply方法通过不同数量的参数调用函数&quot;&gt;使用apply方法通过不同数量的参数调用函数&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用apply方法指定一个可计算的参数数组来调用可变参数的函数
    &lt;ul&gt;
      &lt;li&gt;可变参数或可变元的函数(函数的元数是指其期望的参数个数)&lt;/li&gt;
      &lt;li&gt;apply方法需要一个参数数组，然后将数组的每一个元素作为调用的单独参数调用该函数，除了参数数组，apply方法指定第一个参数绑定到被调用函数的this变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用apply方法的第一个参数给可变参数的方法提供一个接收者&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用arguments创建可变参数的函数&quot;&gt;使用arguments创建可变参数的函数&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用隐式的arguments对象实现可变参数的函数
    &lt;ul&gt;
      &lt;li&gt;JS给每个函数都隐式地提供了一个名为arguments的局部变量。arguments对象给实参提供了一个类似数组的接口。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;考虑对可变参数的函数提供一个额外的固定元数的版本，从而使使用者无需借助apply方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;永远不要修改arguments对象&quot;&gt;永远不要修改arguments对象&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;永远不要修改arguments对象&lt;/li&gt;
  &lt;li&gt;使用[].slice.call(arguments)将arguments对象复制到一个真正的数组中再进行修改
    &lt;ul&gt;
      &lt;li&gt;arguments对象自身并不是标准的Array类型的实例，因此，不能直接调用arguments.shift()方法&lt;/li&gt;
      &lt;li&gt;所有命名参数都是arguments对象中对应索引的别名&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function callMethod(obj, method){
     var shift = [].shift;
     console.log(arguments);
     shift.call(arguments);
     shift.call(arguments);
     console.log(obj);
     console.log(method);
     return obj[method].apply(obj, arguments);
 }
 var obj = {
     add: function(x, y){return x + y;}
 };
 callMethod(obj, 'add', 17, 29);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;在严格模式下，函数参数不支持对其arguments对象取别名&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function strict(x){
     &quot;use strict&quot;;
     arguments[0] = &quot;modified&quot;;
     return x === arguments[0];
 }
 function nonstrict(x){
     arguments[0] = 'modified';
     return x === arguments[0];
 }
 strict(&quot;unmodified&quot;); // false
 nonstrict('unmodified'); // true
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用变量保存arguments的引用&quot;&gt;使用变量保存arguments的引用&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;当引用arguments时当心函数嵌套层级&lt;/li&gt;
  &lt;li&gt;绑定一个明确作用域的引用到arguments变量，从而可以在嵌套的函数中引用它。
    &lt;ul&gt;
      &lt;li&gt;一个新的arguments变量会被隐式的绑定到每个函数体内&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function values(){
    var i = 0, n = arguments.length;
   //  var args = [].slice.call(arguments, 0);
    return {
        hasNext: function(){
            return i &amp;lt; n;
        },
        next: function(){
            if( i &amp;gt;= n ){
                throw  new Error('end of iteration');
            }
            return arguments[i++]; 
         // return args[i++];
        }
    }
}
var it = values(1, 4, 1, 4, 2, 1, 3, 5, 6);
it.next();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;使用bind方法提取具有确定接收者的方法&quot;&gt;使用bind方法提取具有确定接收者的方法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;要注意，提取一个方法不会将方法的接收者绑定到该方法的对象上&lt;/li&gt;
  &lt;li&gt;当给高阶函数传递对象方法时,使用匿名函数在适当的接收者上调用该方法&lt;/li&gt;
  &lt;li&gt;使用bind方法创建绑定到适当函数接收者的函数&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用bind方法实现函数柯里化&quot;&gt;使用bind方法实现函数柯里化&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用bind方法实现函数柯里化，即创建一个固定需求参数子集的委托函数
    &lt;ul&gt;
      &lt;li&gt;在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function simpleURL(protocol, domain, path){
     return protocol + '://' + domain + '/' + path;
 }
 var urls = paths.map(function (path) {
     return simpleURL('http', siteDomain, path);  // 第一个和第二个参数固定
 });
 // 使用bind实现函数柯里化
 var urls = paths.map(simpleURL.bind(null, 'http', siteDomain));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;传入null或undefined作为接收者的参数来实现函数柯里化，从而忽略其接收者&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用闭包而不是字符串来封装代码&quot;&gt;使用闭包而不是字符串来封装代码&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;当将字符串传递给eval函数以执行它们的API时，绝不要在字符串中包含局部变量引用
    &lt;ul&gt;
      &lt;li&gt;eval函数会将出现在字符串中的所有变量引用作为全局变量来解释&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;接受函数调用的API优于使用eval函数执行字符串的API
    &lt;ul&gt;
      &lt;li&gt;函数是一种将代码作为数据结构存储的便利方式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;不要信赖函数对象的tostring方法&quot;&gt;不要信赖函数对象的toString方法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;当调用函数的toString方法时，并没有要求JS引擎能够精确地获取到函数的源代码
    &lt;ul&gt;
      &lt;li&gt;ECMAScript标准对函数对象的toString方法的返回结果(即该字符串)并没有任何要求&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;由于在不同的引擎下调用toString方法的结果可能不同，所以绝不要信赖函数源代码的详细细节&lt;/li&gt;
  &lt;li&gt;toString方法的执行结果并不会暴露存储在闭包中的局部变量值&lt;/li&gt;
  &lt;li&gt;通常情况下，应该避免使用函数对象的toString方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免使用非标准的栈检查属性&quot;&gt;避免使用非标准的栈检查属性&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;避免使用非标准的arguments.caller和arguments.callee属性，因为它们不具备良好的移植性
    &lt;ul&gt;
      &lt;li&gt;现在宿主环境中已经不支持arguments.caller，但还支持arguments.callee(其指向使用该arguments对象被调用的函数，它除了允许匿名函数递归地引用其自身没有更多用途)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;避免使用非标准的函数对象calller属性，因为在包涵全部栈信息方面，它是不可靠的。
    &lt;ul&gt;
      &lt;li&gt;调用栈事指当前正在执行的活动函数链&lt;/li&gt;
      &lt;li&gt;栈跟踪是一个提供当前调用栈快照的数据结构&lt;/li&gt;
      &lt;li&gt;ES5中如果试图获取严格函数或arguments对象的caller或callee属性都将抛出一个错误&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;对象和原型&quot;&gt;对象和原型&lt;/h2&gt;
&lt;h3 id=&quot;理解prototypegetprototypeof和__proto__之间的不同&quot;&gt;理解prototype、getPrototypeOf和__proto__之间的不同&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;原型包括三个独立但相关的访问器
    &lt;ul&gt;
      &lt;li&gt;C.prototype用于建立由new C()创建的对象的原型&lt;/li&gt;
      &lt;li&gt;Object.getPrototypeOf(obj)是ES5中用来获取obj对象的原型对象的标准方法&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;obj.__proto__&lt;/code&gt;是获取obj对象的原型对象的非标准方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类是由一个构造函数和一个关联的原型组成的一种设计模式&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // User看成一个类,User函数给该类提供了一个公告的构造函数,
 // 而User.prototype是实例之间共享方法的一个内部实现
 function User(name, password){
 	this.name = name;
 	this.password = password;
 }
 User.prototype.toString = function(){
     return &quot;[User &quot;  + this.name + &quot;]&quot;;
 };
 User.prototype.checkPassword = function(password){
     return password === this.password;
 };
 var user = new User('admin', 'root');
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用objectgetprototypeof函数而不使用__proto__属性&quot;&gt;使用Object.getPrototypeOf函数而不使用__proto__属性&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用符合标准的Object.getPrototypeOf函数而不要使用非标准的__proto__属性&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在支持__proto__属性的非ES5环境中实现Object.getPrototypeOf函数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; if(typeof Object.getPrototypeOf === 'undefined'){
     Object.getPrototypeOf = function(obj){
          var t = typeof obj;
          if(!obj || (t !== 'object' &amp;amp;&amp;amp; t !== 'function')){
          	throw new TypeError('not an object');
          }
          return obj.__proto__;
     }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;始终不要修改__proto__属性&quot;&gt;始终不要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;属性&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;始终不要修改对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;属性
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;具有修改对象原型链接的能力&lt;/li&gt;
      &lt;li&gt;可移植性问题:并不是所有平台都支持改变对象原型的特性&lt;/li&gt;
      &lt;li&gt;修改&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;属性实际上改变了继承结构本身，这可能是最具破坏性的修改&lt;/li&gt;
      &lt;li&gt;为了保持行为的可预测性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 Object.create函数给新对象设置自定义的原型
    &lt;ul&gt;
      &lt;li&gt;使用ES5中的Object.create函数来创建一个具有自定义原型链的新对象 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create(proto, [ propertiesObject ])&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使构造函数与new操作符无关&quot;&gt;使构造函数与new操作符无关&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通过使用new操作符或Object.create方法在构造函数定义中调用自身使得该构造函数与调用语法无关。
    &lt;ul&gt;
      &lt;li&gt;如果使用者忘记使用new关键字，那么函数的接收者将是全局对象&lt;/li&gt;
      &lt;li&gt;使用严格的构造函数至少会帮助调用者尽早地发现该Bug并修复它&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function User(name, password){
     //   &quot;use strict&quot;;
 	this.name = name;
 	this.password = password;
 }
 var user = User('admin', 'root');
 user;    // undefined
 name;   //&quot;admin&quot;
 password; // &quot;root&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;检查函数的接收者是否是一个正确的User实例&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function User(name, password){
     if(!(this instanceof User)){
         return new User(name, password);
     }
     this.name = name;
     this.password = password;
 }
 // 该函数需要额外的函数调用，代价有点高，并且它很难适用于可变参数函数
 function User(name, password){
     var self = this instanceof User ? this : Object.create(User.prototype);
     self.name = name;
     self.password = password;
     return self;
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Object.create兼容函数&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 简单参数版本
 if(typeof Object.create === &quot;undefined&quot;){
     Object.create = function(prototype){
         function C(){};
         C.prototype = prototype;
         return new C();
     }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;JavaScript允许表达式的结果可以被构造函数中的显示return语句所覆盖&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当一个函数期望使用new操作符调用时,清晰地文档化该函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;在原型中存储方法&quot;&gt;在原型中存储方法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;将方法存储在实例对象中将创建该函数的多个副本，因为每一个实例对象都有一份副本&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将方法存储于原型优于存储在实例对象中&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function User(name, password){
     this.name = name;
     this.password = password;
     this.toString = function(){
         return &quot;[User &quot;  + this.name + &quot;]&quot;;
     };
     this.checkPassword = function(password){
         return password === this.password;
     };
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用闭包存储私有数据&quot;&gt;使用闭包存储私有数据&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;闭包变量是私有的，只能通过局部的引用获取
    &lt;ul&gt;
      &lt;li&gt;闭包: 将数据存储到封闭的变量中而不提供对这些变量的直接访问，获取闭包内部结构的唯一方式是该函数显示地提供获取它的途径&lt;/li&gt;
      &lt;li&gt;对象和闭包具有相反策略:对象的属性会被自动地暴露出去，然而闭包中的变量会被自动地隐藏起来&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将局部变量作为私有数据从而通过方法实现信息隐蔽&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function User(name, password){
     this.toString = function(){
         return &quot;[User &quot;  + name + &quot;]&quot;;
     };
     this.checkPassword = function(password){
         return password === password;
     };
 }
 // 缺点: 这些方法必须置于实例对象中
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;只将实例状态存储在实例对象中&quot;&gt;只将实例状态存储在实例对象中&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;共享可变数据可能会出问题，因为原型是被其所有的实例共享的。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function Tree(x){
     this.value = x;
 }
 Tree.prototype = {
     children: [],
     addChild: function(x){
         this.children.push(x);
     }
 };
 var left = new Tree(2);
 left.addChild(1);
 left.addChild(3);
 var right = new Tree(6);
 right.addChild(5);
 right.addChild(7);
 right.children;  //[1, 3, 5, 7]
 left.children;  //[1, 3, 5, 7]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将可变的实例状态存储在实例对象中&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;一般情况下，任何不可变的数据可以被存储在原型中从而被安全地共享&lt;/li&gt;
      &lt;li&gt;在原型对象中最常见的数据是方法，而每个实例的状态都存储在实例对象中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;认识到this变量的隐式绑定问题&quot;&gt;认识到this变量的隐式绑定问题&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;this变量的作用域总是由其最近的封闭函数所确定&lt;/li&gt;
  &lt;li&gt;使用一个局部变量(通常命名为self,me或that)使得this绑定对于内部函数是可以用的&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;在子类的构造函数中调用父类的构造函数&quot;&gt;在子类的构造函数中调用父类的构造函数&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在子类构造函数中显示地传入this作为显示的接收者调用父类构造函数&lt;/li&gt;
  &lt;li&gt;使用Object.create函数来构造子类的原型对象以避免调用父类的构造函数&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;不要重用父类的属性名&quot;&gt;不要重用父类的属性名&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;留意父类使用的所有属性名
    &lt;ul&gt;
      &lt;li&gt;如果在继承体系中的两个类指向相同的属性名，那么它们指向的是同一个属性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不要在子类中重用父类的属性名&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免继承标准类&quot;&gt;避免继承标准类&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;继承标准类往往会由于一些特殊的内部属性(如[[Class]])而被破坏
    &lt;ul&gt;
      &lt;li&gt;JS标准规定它具有一些不可见的内部属性，称为[[Class]]&lt;/li&gt;
    &lt;/ul&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;[[CLass]]&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;constructor&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;“Array”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new Array(…),[…]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“Boolean”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new Boolean(…)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“Date”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new Date(…)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“Error”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new Error(…),new EvalError(),new RangeError(),new ReferenceError(),new SyntaxError(),new TypeError(),new URIError()&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“Function”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new Function(…),function(…){…}&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“JSON”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;JSON&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“Math”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;Math&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“Number”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new Number(…)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“Object”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new Object(…), {…}, new MyClass(…)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“RegExp”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new RegExp(…), /…/&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;“String”&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;new String(…)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;基于这个原因，最好避免继承一下的标准类: Array、Boolean、Date、Function、Number、RegExp或String
    &lt;ol&gt;
      &lt;li&gt;使用属性委托优于继承标准类&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;将原型视为实现细节&quot;&gt;将原型视为实现细节&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;对象是接口，原型是实现
    &lt;ul&gt;
      &lt;li&gt;使用者与一个对象最基本的交互就是获取其属性值和调用其方法。&lt;/li&gt;
      &lt;li&gt;原型是一种对象行为的实现细节。&lt;/li&gt;
      &lt;li&gt;JS提供内省机制来检查对象的细节
        &lt;ul&gt;
          &lt;li&gt;Object.prototype.hasOwnProperty方法确定一个属性是否为对象’自己的’属性&lt;/li&gt;
          &lt;li&gt;Object.getPrototypeOf和&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;特性允许程序员遍历对象的原型链并单独查询其原型对象&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;避免检查你无法控制的对象的原型结构&lt;/li&gt;
  &lt;li&gt;避免检查实现在你无法控制的对象内部的属性&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免使用轻率的猴子补丁&quot;&gt;避免使用轻率的猴子补丁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;避免使用轻率的猴子补丁
    &lt;ul&gt;
      &lt;li&gt;猴子补丁: 对象共享原型，每个对象都可以增加、删除或修改原型的属性的实践。&lt;/li&gt;
      &lt;li&gt;当多个库以不兼容的方式给同一个原型打猴子补丁时问题就出现了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;记录程序库所执行的所有猴子补丁
    &lt;ul&gt;
      &lt;li&gt;两个以冲突的方式给原型打猴子补丁的程序不能在同一个程序中使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;考虑通过将修改置于一个导出函数中，使猴子补丁称为可选的&lt;/li&gt;
  &lt;li&gt;使用猴子补丁为缺失的标准API提供polyfills
    &lt;ul&gt;
      &lt;li&gt;通过使用带有测试条件的守护猴子补丁来安全地弥补平台的差距&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; if(typeof Array.prototype.map !== 'function'){
     Array.prototype.map = function(f, thisArg){
         var result = [];
         for(var i = 0; i &amp;lt; thisArg.length; i++){
             result[i] = f.call(thisArg, this[i], i);
         }
         return result;
     }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数组和字典&quot;&gt;数组和字典&lt;/h2&gt;
&lt;h3 id=&quot;使用object的直接实例构造轻量级的字典&quot;&gt;使用Object的直接实例构造轻量级的字典&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用对象字面量构建轻量级字典&lt;/li&gt;
  &lt;li&gt;轻量级字典应该是Object.prototype的直接子类，以使for…in循环免受原型污染
    &lt;ul&gt;
      &lt;li&gt;原型污染是指当枚举字典的条目时，原型对象中的属性可能会导致出现一些不期望的属性&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function NaiveDict(){}
 NaiveDict.prototype.count = function(){
     var i = 0;
     for(var name in this){
         i++;
         console.log(name)
     }
     return i;
 };
 NaiveDict.prototype.toString = function(){
     return &quot;[object NaiveDict]&quot;;
 };
 var dict = new NaiveDict();
 dict.alice = 34;
 dict.bob = 24;
 dict.chris = 62;
 dict.count();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;将Object的直接实例作为字典，而不是其子类，当然也不是数组
        &lt;ul&gt;
          &lt;li&gt;所有人都不应当增加属性到Object.prototype中，因为这样做可能会污染for…in循环，但是增加属性到Array.prototype中是合理的&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var dict = {};
 dict.alice = 34;
 dict.bob = 24;
 dict.chris = 62;
 var names = [];
 for(var name in dict){
     names.push(name);
 }
 names;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用null原型以防止原型污染&quot;&gt;使用null原型以防止原型污染&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在ES5中环境中，使用Object.create(null)创建的自由原型的空对象是不太容易被污染的。
    &lt;ul&gt;
      &lt;li&gt;防止原型污染的最简单方式之一就是一开始就不要使用原型&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var x = Object.create(null);
 Object.getPrototypeOf(x) === null;  // true
 // 使用__proto__
 var o = {__proto__: null};
 o instanceof Object; // false
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在一些较老的环境中，考虑使用{&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;:null}&lt;/li&gt;
  &lt;li&gt;但是要注意&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;既不标准，也不是完全可移植的，并且可能会在未来的JS环境中去除&lt;/li&gt;
  &lt;li&gt;绝不要使用”&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;“名作为字典中的key,因为一些环境将其作为特殊的属性对待&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用hasownproperty方法以避免原型污染&quot;&gt;使用hasOwnProperty方法以避免原型污染&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用hasOwnProperty方法避免原型污染&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用词法作用域和call方法避免覆盖hasOwnProperty方法&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var hasOwn = Object.prototype.hasOwnProperty;
 // 更加简明
 var hasOwn = {}.hasOwnProperty;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考虑在封装hasOwnProperty测试样板代码的类中实现字典操作&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function Dict(elements){
     this.elements = elements || {};
 }
 Dict.prototype.has = function(key){
     return {}.hasOwnProperty.call(this.elements, key);
 };
 Dict.prototype.get = function (key) {
     return this.has(key) ? this.elements[key] : undefined;
 };
 Dict.prototype.set = function(key, val){
     this.elements[key] = val;
 };
 Dict.prototype.remove = function (key) {
     delete this.elements[key];
 };
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;使用字典类避免将”&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;“作为key来使用&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用数组而不要使用字典来存储有序集合&quot;&gt;使用数组而不要使用字典来存储有序集合&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用for…in循环来枚举对象属性应当与顺序无关
    &lt;ul&gt;
      &lt;li&gt;for…in循环会挑选一定的顺序来枚举对象的属性，如果要依赖一个数据结构中的条目顺序，请使用数组而不是字典&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果聚集运算字典中的数据，确保聚集操作与顺序无关&lt;/li&gt;
  &lt;li&gt;使用数组而不是字典来存储有序集合&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var ratings = {
    &quot;Good Will Hunting&quot;: 0.8,
    &quot;Mystic River&quot;: 0.7,
    &quot;21&quot;: 0.6,
    &quot;Doubt&quot;: 0.9
};
var total = 0, count = 0;
for(var key in ratings){
    total += ratings[key];
    count++;
}
total /= count;
console.log(total);  // 0.7499999999999999
(0.8 + 0.7 + 0.6 + 0.9)/4;   // 0.75
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;绝不要在objectprototype中增加可枚举的属性&quot;&gt;绝不要在Object.prototype中增加可枚举的属性&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;避免在Object.prototype中增加属性
    &lt;ul&gt;
      &lt;li&gt;如果想允许对字典对象使用for…in循环，那么不要在共享的Object.prototype中增加可枚举的属性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;考虑编写一个函数代替Object.prototype方法&lt;/li&gt;
  &lt;li&gt;如果你确实需要在Object.prototype中增加属性，使用ES5中国的Object.defineProperty方法将它们定义为不可枚举的属性
    &lt;ul&gt;
      &lt;li&gt;Object.defineProperty方法可以定一个对象的属性并指定该属性的元数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免在枚举期间修改对象&quot;&gt;避免在枚举期间修改对象&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;当使用for…in循环枚举一个对象的属性时，确保不要修改该对象
    &lt;ul&gt;
      &lt;li&gt;如果被枚举的对象在枚举期间添加了新的属性，那么在枚举期间并不能保证新添加的属性能被访问。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function Member(name) {
     this.name = name;
     this.friends = [];
 }
 var a = new Member('Alice'),
     b = new Member('Bob'),
     c = new Member('Carol'),
     d = new Member('Dieter'),
     e = new Member('Eli'),
     f = new Member('Fatima');
 a.friends.push(b);
 b.friends.push(c);
 c.friends.push(e);
 d.friends.push(b);
 e.friends.push(d,f);
 Member.prototype.inNetwork = function(other){
     var visited = {};
     var workset = {};
     workset[this.name] = this;
     for(name in workset){
         var member = workset[name];
         delete workset[name];
         if(name in visited){
             continue;
         }
         visited[name] = member;
         if(member === other) {
             return true;
         }
         member.friends.forEach(function(friend){
             workset[friend.name] = friend;
         });
     }
     return false;
 };
 a.inNetwork(f);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环来代替for…in循环&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Member.prototype.inNetwork = function(other){
     var visited = {};
     var workset = [this];
     while(workset.length &amp;gt; 0){
         var member = workset.pop();
         console.log(member);
         if(member.name in visited){
             continue;
         }
         visited[member.name] = member;
         if(member === other) {
             return true;
         }
         member.friends.forEach(function(friend){
             workset.push(friend);
         });
     }
     return false;
 };
 a.inNetwork(f);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组而不要使用字典对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;数组迭代要优先使用for循环而不是forin循环&quot;&gt;数组迭代要优先使用for循环而不是for…in循环&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;迭代数组的索引属性应当总是使用for循环而不是for…in循环&lt;/li&gt;
  &lt;li&gt;考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度
    &lt;ul&gt;
      &lt;li&gt;保证避免重新计算scores.length是安全的&lt;/li&gt;
      &lt;li&gt;循环的终止条件是简单且确定的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;迭代方法优于循环&quot;&gt;迭代方法优于循环&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用迭代方法(如Array.prototype.forEach和Array.prototype.map)替换for循环使得代码更可读，并且避免了重复循环控制逻辑
    &lt;ul&gt;
      &lt;li&gt;Array.prototype.forEach，代码简单可读，且消除了终止条件和任何数组索引&lt;/li&gt;
      &lt;li&gt;Array.prototype.map，对数组的每个元素进行一些操作后建立一个新的数组，该方法模式更简单和优雅&lt;/li&gt;
      &lt;li&gt;Array.prototype.filter，用于计算一个新的数组，该数组包含现有数组的一些元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用自定义的迭代函数来抽象未被标准库支持的常见循环模式&lt;/li&gt;
  &lt;li&gt;在需要提前终止循环的情况下，仍然推荐使用传统的循环。另外，some和every方法也可用于提前退出
    &lt;ul&gt;
      &lt;li&gt;循环只有一点优于迭代函数，那就是前者有控制流操作，如break和continue&lt;/li&gt;
      &lt;li&gt;迭代中可以使用一个内部异常来终止循环，但这既尴尬又效率低下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;在类数组对象上复用通用的数组方法&quot;&gt;在类数组对象上复用通用的数组方法&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;对于类数组对象，通过提取方法对象并使用call方法来复用通用的Array方法
    &lt;ul&gt;
      &lt;li&gt;字符串也表现为不可变的数组，因为它们是可索引的，并且其长度也可以通过length属性获取，因此Array.prototype中的方法操作字符串时并不会修改原始数组&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var str = 'abcdef';
 var result = [].map.call(str, function(s){
     return s.toUpperCase();
 });
 result;  //[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任意一个具有索引属性和恰当length属性的对象都可以使用通用的Array方法&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var arrayLike = {'0':'a', '1':'C', length:2};
 var result = [].map.call(arrayLike, function(s){
     return s.toUpperCase();
 })
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;数组字面量优于数组构造函数&quot;&gt;数组字面量优于数组构造函数&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;如果数组构造函数第一个参数是数字则数组的构造函数行为是不同的
    &lt;ul&gt;
      &lt;li&gt;首先必须确保，没有人重新包装过Array变量&lt;/li&gt;
      &lt;li&gt;确保没人修改过全局的Array变量&lt;/li&gt;
      &lt;li&gt;如果使用单个数字参数来调用Array构造函数，效果完全不同&lt;code class=&quot;highlighter-rouge&quot;&gt;[17]与Array(17)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用数组字面量替代数组构造函数
    &lt;ul&gt;
      &lt;li&gt;字面量是一种表示数组的优雅的方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;库和api设计&quot;&gt;库和API设计&lt;/h2&gt;
&lt;h3 id=&quot;保持一致性的约定&quot;&gt;保持一致性的约定&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在变量命名和函数标签中使用一致的约定
    &lt;ul&gt;
      &lt;li&gt;学习曲线尽可能的简单&lt;/li&gt;
      &lt;li&gt;约定参数的顺序,确保参数总是以相同的顺序出现&lt;/li&gt;
      &lt;li&gt;需要尽可能详尽的稳定&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不要偏离用户在他们开发平台中很可能遇到的约定&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;将undefined看做没有值&quot;&gt;将undefined看做’没有值’&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;避免使用undefined表示任何非特定值
    &lt;ul&gt;
      &lt;li&gt;当JS无法提供具体的值时，就产生undefined
        &lt;ul&gt;
          &lt;li&gt;未赋值的变量的初始值即为undefined&lt;/li&gt;
          &lt;li&gt;访问对象中不存在的属性也会产生undefined&lt;/li&gt;
          &lt;li&gt;一个函数体结尾使用未带参数的return语句，或未使用return语句都会产生返回值undefined&lt;/li&gt;
          &lt;li&gt;未给参数提供实参则该函数参数值为undefined&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用描述性的字符串值或命名布尔属性的对象，而不要使用undefined或null来代表特定应用标志&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  element.highlight(undefined); //use a random color
  element.highlight('random'); //use a random color
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供参数默认值应当采用测试undefined的方式，而不是检查arguments.length&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function Server(port, hostname){
     if(arguments.length &amp;lt; 2){
         hostname = 'localhost';
     }
     // hostname = String(hostname || 'localhost');  
     hostname = String(hostname);
     console.log(hostname);
     // ...
 }
 var hostname;
 var port = 8080;
 Server(port, hostname);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在允许0、NaN或空字符串为有效参数的地方，绝不要通过真值测试来实现参数默认值&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;接收关键字参数的选项对象&quot;&gt;接收关键字参数的选项对象&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用选项对象使得API更具可读性、更容易记忆
    &lt;ul&gt;
      &lt;li&gt;JS提供了一个简单、轻量的惯用法:选项对象(options object)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;所有通过选项对象提供的参数应当被视为可选的
    &lt;ul&gt;
      &lt;li&gt;选项对象所有参数都是可选的&lt;/li&gt;
      &lt;li&gt;习惯上，选项对象仅包括可选参数，因此省略掉整个对象甚至是可能的&lt;/li&gt;
      &lt;li&gt;如果有一个或者两个必选参数，最好使它们独立于选项对象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用extend函数抽象出从选项对象中提取值的逻辑
    &lt;ul&gt;
      &lt;li&gt;有用的抽象(对象扩展或合并函数)&lt;/li&gt;
      &lt;li&gt;枚举对象的属性，并当这些属性不是undefined时将其复制到目标对象中&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;使用或(&lt;/td&gt;
              &lt;td&gt; &lt;/td&gt;
              &lt;td&gt;)操作符是一种提供默认参数值有效但非一致的策略，一致性是库设计的一个良好目标，它给API的使用者带来更好的可选测性&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免不必要的状态&quot;&gt;避免不必要的状态&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;尽可能地使用无状态的API
    &lt;ul&gt;
      &lt;li&gt;API有时被归为两类:有状态和无状态的&lt;/li&gt;
      &lt;li&gt;无状态的API提供的函数或方法的行为只取决于输入。字符串的方法是无状态的&lt;/li&gt;
      &lt;li&gt;Date对象的方法是有状态的&lt;/li&gt;
      &lt;li&gt;相比于有状态的API，无状态的API会自动重用默认值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果API是有状态的，标示出每个操作与哪些状态有关联&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用结构类型设计灵活的接口&quot;&gt;使用结构类型设计灵活的接口&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用结构类型(也称鸭子类型)来设计灵活的对象接口&lt;/li&gt;
  &lt;li&gt;结构接口更灵活、更轻量，所以应该避免使用继承&lt;/li&gt;
  &lt;li&gt;针对单元测试，使用mock对象即接口的替代实现来提供可复验的行为&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;区分数组对象和类数组对象&quot;&gt;区分数组对象和类数组对象&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;绝不重载与其它类型有重叠的结构类型&lt;/li&gt;
  &lt;li&gt;当重载一个结构类型与其它类型时，先测试其它类型&lt;/li&gt;
  &lt;li&gt;当重载其它对象类型时，接收真数组而不是类数组对象&lt;/li&gt;
  &lt;li&gt;文档标注你的API是否接收针数组或类数组值&lt;/li&gt;
  &lt;li&gt;使用ES5提供的Array.isArray方法测试真数组&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;避免过度的强制转换&quot;&gt;避免过度的强制转换&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;避免强制转换和重载的复用
    &lt;ul&gt;
      &lt;li&gt;强制转换会将方法的参数强制转换从而完全破坏重载&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=4K_F59Sw4JtanVpVeXzvXrph47UpLAkPPzuRGq34MKnKYa7WQyiXmuZX6u6gatKDm2L0qnOnWaEGATgOnTWBma&quot;&gt;方法重载&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;考虑防御性地监视非预期的输入
    &lt;ul&gt;
      &lt;li&gt;防御式编程:试图以额外的检查来抵御潜在的错误(抵御所有的错误是不可能的)&lt;/li&gt;
      &lt;li&gt;防御式编程可以帮助更早的捕获错误，但是其可能扰乱代码库并潜在地影响应用程序的性能。&lt;/li&gt;
      &lt;li&gt;是否使用防御式编程:成本(不得不编写和执行额外测试的数量)和收益(更早捕获错误数，节省开发和调试时间)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;支持方法链&quot;&gt;支持方法链&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用方法链来连接无状态的操作
    &lt;ul&gt;
      &lt;li&gt;重复的方法调用风格叫做方法链.&lt;/li&gt;
      &lt;li&gt;消除临时变量，中间结果只是得到最终结果的一个重要步骤而已&lt;/li&gt;
      &lt;li&gt;方法链的方式非常灵活&lt;/li&gt;
      &lt;li&gt;如果一个API产生了1个接口对象，调用这个接口对象的方法产生的对象如果具有相同的接口，那么就可以使用方法链&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function escapeBasicHTML(str){
  	return str.replace(/&amp;amp;/g, &quot;&amp;amp;amp;&quot;)
              .replace(/&amp;lt;/g, &quot;&amp;amp;lt;&quot;)
              .replace(/&amp;gt;/g, &quot;&amp;amp;gt;&quot;)
              .replace(/&quot;/g, &quot;&amp;amp;quot;&quot;)
              .replace(/'/g, &quot;&amp;amp;apos;&quot;)
  }
  var html = '&amp;lt;span class=&quot;vote-count&quot;&amp;gt;175&amp;lt;/span&amp;gt;'
  escapeBasicHTML(html); 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;通过在无状态的方法中返回新对象来支持方法链&lt;/li&gt;
  &lt;li&gt;通过在有状态的方法中返回this来支持方法链
    &lt;ul&gt;
      &lt;li&gt;有状态的API的方法链有时被称为流畅式(fluent style,一个对单个对象调用多个方法的内置的语法)&lt;/li&gt;
      &lt;li&gt;前端库jQuery普遍采用这种方法，它有一组(无状态的)方法用于从用户界面元素中查询网页,还有一组(有状态的)方法用于更新这些元素。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $('#notification')     // 查找notification元素
      .html('Server not responding.')   // 设置notification消息
      .removeClass('info')    // 移除设置样式
      .addClass('error')    // 添加样式
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;并发&quot;&gt;并发&lt;/h2&gt;

&lt;p&gt;JS是一种嵌入式的脚本语言，JS不是以独立的应用程序运行，而是作为大型应用程序环境下的脚本运行。&lt;/p&gt;

&lt;p&gt;使用事件和异步API是JS编程的基础部分。&lt;/p&gt;

&lt;h3 id=&quot;不要阻塞io事件队列&quot;&gt;不要阻塞I/O事件队列&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序.
    &lt;ul&gt;
      &lt;li&gt;异步的API用在基于事件的环境中事安全的，因为它们迫使应用程序逻辑在一个独立的事件循环‘轮询’中继续处理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JS并发地接收事件，但会使用一个事件队列按序地处理事件处理程序
    &lt;ul&gt;
      &lt;li&gt;并行执行子计算:允许程序的一部分停下来等待(阻塞)一个低速的输入，而程序的另一部分可以继续进行独立的工作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在应用程序事件队列中绝不要使用阻塞的I/O
    &lt;ul&gt;
      &lt;li&gt;大多数的I/O操作都提供了异步的或非阻塞的API&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;在异步序列中使用嵌套或命名的回调函数&quot;&gt;在异步序列中使用嵌套或命名的回调函数&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用嵌套或命名的回调函数按顺序地执行多个异步操作
    &lt;ul&gt;
      &lt;li&gt;理解操作序列的最简单的方式是异步API是发起操作而不是执行操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;尝试在过多的嵌套的回调函数和尴尬的命名的非嵌套回调函数之间取得平衡
    &lt;ul&gt;
      &lt;li&gt;嵌套的异步操作很容易，但当扩展到更长的序列时会很快变得笨拙&lt;/li&gt;
      &lt;li&gt;减少过多嵌套的方法之一是将嵌套的回调函数作为命名的函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;避免将可被并行执行的操作顺序化&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;当心丢弃错误&quot;&gt;当心丢弃错误&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通过编写共享的错误处理函数来避免复制和粘贴错误处理代码&lt;/li&gt;
  &lt;li&gt;确保明确地处理所有的错误条件以避免丢弃错误
    &lt;ul&gt;
      &lt;li&gt;多部的处理通常被分隔到事件队列的单独轮次中&lt;/li&gt;
      &lt;li&gt;异步的API甚至不可能抛出异常，异步的API倾向于将错误表示为回调函数的特定参数，或使用一个附加的错误处理回调函数(有事被称为errbacks)&lt;/li&gt;
      &lt;li&gt;另一种错误处理API，主要一个回调函数，该回调函数的第一个参数如果有错误发生那就表示为一个错误，否则就为一个假值,比如null&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;对异步循环使用递归&quot;&gt;对异步循环使用递归&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;循环不能是异步的&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function downloadOneSync(urls){
     for(var i = 0; n = urls.length; i++){
         try{
             return downloadSync(urls[i]);
         }catch(e){}
     }
     throw new Error('all downloads failed');
 }
 // 以上使用循环，会启动所有下载
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用递归函数再事件循环的单独轮次中执行迭代&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function downloadOneSync(urls, onsuccess, onerror){
     var n = urls.length;
     function tryNextURL(i){
         if(i &amp;gt;= n){
             onerror('all downloads failed');
             return;
         }
         downloadSync(urls[i], onsuccess, function(){
             tryNextURL(i + 1);
         });
     }
     tryNextURL(0);
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在事件循环的单独轮次中执行递归，并不会导致调用栈溢出&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;JS环境通常在内存中会保存一块固定的区域，称为调用栈，用于记录函数调用返回前下一步该做什么。&lt;/li&gt;
      &lt;li&gt;当一个程序执行中有太多的函数调用，它会耗尽栈空间，最终抛出异常。这种情况被称为栈溢出&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;不要在计算时阻塞事件队列&quot;&gt;不要在计算时阻塞事件队列&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;避免在主事件队列中执行代价高昂的算法
    &lt;ul&gt;
      &lt;li&gt;为了保持客户端应用程序的高度交互性和确保所有传入的请求在服务器应用程序中得到充分的服务，保持事件循环的每个轮次尽可能短是至关重要的。&lt;/li&gt;
      &lt;li&gt;一个页面的用户界面无响应多数是由于在运行JS代码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在支持Worker API的平台，该API可以用来在一个独立的事件队列中运行长计算程序&lt;/li&gt;
  &lt;li&gt;在Worker API不可用或代价昂贵的环境中，考虑将计算程序分解到事件循环的多个轮次中&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用计数器来执行并行操作&quot;&gt;使用计数器来执行并行操作&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;JS应用程序中的事件发生是不确定的，即顺序是不可预测的&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function downloadAllAsync(urls, onsuccess, onerror){
     var result = [], length = urls.length;
     if(length === 0){
         setTimeout(onsuccess.bind(null, result), 0);
         return;
     }
     urls.forEach(function(url){
         downloadSync(url, function(text){
             if(result){
                 result.push(text);
                 if(result.length === urls.length){
                     onsuccess(result);
                 }
             }
         }, function(error){
             if(result){
                 result = null;
                 onerror(error);
             }
         })
     });
 }
 // 以上代码异步的启动文件下载，当文件下载完成就会将中间结果保存在result数组的末尾，因此保存下载文件内容的数组的顺序是未知的，因此调用者无法找出哪个结果对应哪个文件
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;如果行为不可预知，则不能信赖程序中不确定的行为，即程序的执行顺序不能保证与事件发生的顺序一致&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用计数器避免并行操作中的数据竞争&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;数据竞争是指多个并发操作可以修改共享的数据结构，这取决于它们发生的顺序&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function downloadAllAsync(urls, onsuccess, onerror){
 var result = [], pending = urls.length;
 if(pending === 0){
     setTimeout(onsuccess.bind(null, result), 0);
     return;
 }
 urls.forEach(function(url, i){
     downloadSync(url, function(text){
         if(result){
             result[i] = text;  //存储在固定index
             pending--;
             if(pending === 0){
                 onsuccess(result);
             }
         }
     }, function(error){
         if(result){
             result = null;
             onerror(error);
         }
     })
 });
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;绝不要同步地调用异步的回调函数&quot;&gt;绝不要同步地调用异步的回调函数&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;即使可以立即得到数据，也绝不要同步地调用异步回调函数&lt;/li&gt;
  &lt;li&gt;同步地调用异步的回调函数扰乱了预期的操作序列，并可能导致意想不到的交错代码&lt;/li&gt;
  &lt;li&gt;同步地调用异步的回调函数可能导致栈溢出或错误地处理程序&lt;/li&gt;
  &lt;li&gt;使用异步的API，比如setTimeout函数来调度异步回调函数，使其运行于另一个回合&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var cache = new Dict();
function downloadCachingAsync(url, onsuccess, onerror){
    if(cache.has(url)){
        onsuccess(cache.get(url));  // 同步调用
        // var cached = cache.get(url);
        // setTimeout(onsuccess.bind(null, cached), 0);  // 异步调用
        return;
    }
    return downloadAsync(url, function(file){
        cache.set(url, file);
        onsuccess(file);
    }, onerror);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;使用promise模式清洁异步逻辑&quot;&gt;使用promise模式清洁异步逻辑&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;promise代表最终值，即并行操作完成时最终产生的结果
    &lt;ul&gt;
      &lt;li&gt;基于promise的API不接收回调函数作为参数,相反它返回一个promise对象，该对象通过其自身的then方法接收回调函数。&lt;/li&gt;
      &lt;li&gt;传递给then的回调函数不仅产生影响，也可以产生结果(resolve中返回值在下一个then中接收)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用promise组合不同的并行操作
    &lt;ul&gt;
      &lt;li&gt;promise.all、promise.race等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用promise模式的API避免数据竞争&lt;/li&gt;
  &lt;li&gt;在要求有意的竞争条件时使用select(也被称为choose)&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;函数&lt;a href=&quot;http://www.cnblogs.com/pigtail/p/3447660.html&quot;&gt;柯里化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;[http://www.ruanyifeng.com/blog/2014/12/unicode.html&quot;&gt;Unicode与JS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/25786138/&quot;&gt;Effective JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/effective-javascript/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/effective-javascript/</guid>
        
        <category>JS</category>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>Date简介</title>
        <description>&lt;h1 id=&quot;date知识分享&quot;&gt;Date知识分享&lt;/h1&gt;
&lt;h2 id=&quot;起源&quot;&gt;起源&lt;/h2&gt;
&lt;p&gt;java中java.util.Date类基础上构建的。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;Date类型使用自UTC(Coordinated Universal Time,国际协调时间)1970年1月1日午夜(零时)开始经过的毫秒数来保存日期.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。但是GMT是一个时区，UTC是一个时间标准.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;
&lt;h3 id=&quot;创建&quot;&gt;创建&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Date.parse
    &lt;ul&gt;
      &lt;li&gt;定义: 接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应的日期的毫秒数。&lt;/li&gt;
      &lt;li&gt;语法: Date.parse(datestring)
        &lt;ul&gt;
          &lt;li&gt;datestring:必需,表示日期和时间的字符串。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;Date.parse()是Date对象的静态方法。&lt;/li&gt;
          &lt;li&gt;如果传入Date.parse()方法的字符串不能表示日期,那么它会返回NaN.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Date.UTC
    &lt;ul&gt;
      &lt;li&gt;定义: 根据世界时返回1970年1月1日到指定日期的毫秒数。&lt;/li&gt;
      &lt;li&gt;语法: Date.UTC(year,month,day,hours,minutes,seconds,ms)
        &lt;ul&gt;
          &lt;li&gt;year: 必需。表示年份的四位数字。&lt;/li&gt;
          &lt;li&gt;month: 必需。表示月份的整数，介于0~11。&lt;/li&gt;
          &lt;li&gt;day: 必需。表示日期的整数，介于1~31。&lt;/li&gt;
          &lt;li&gt;hours: 可选。表示小时的整数，介于0~23。&lt;/li&gt;
          &lt;li&gt;minutes: 可选。表示分钟的整数，介于0 ~ 59。&lt;/li&gt;
          &lt;li&gt;seconds: 可选。表示秒的整数，介于0 ~ 59。&lt;/li&gt;
          &lt;li&gt;ms: 可选。表示毫秒的整数，介于0 ~ 999。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;返回指定的时间距 GMT 时间1970年1月1日午夜的毫秒数。&lt;/li&gt;
          &lt;li&gt;Date.UTC()是一种静态方法，因为需要使用构造函数Date来调用它&lt;/li&gt;
          &lt;li&gt;Date.UTC()方法的参数指定日期和时间，它们都是UTC时间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var minutes = 1000 * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var t = Date.UTC(2005,7,8);
  var y = t/years;
  document.write(&quot;It's been: &quot; + y + &quot; years from 1970/01/01&quot;);
  document.write(&quot; to 2005/07/08!&quot;);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Date
    &lt;ul&gt;
      &lt;li&gt;定义: 用于处理日期和时间&lt;/li&gt;
      &lt;li&gt;语法: new Date(dateStr)
        &lt;ul&gt;
          &lt;li&gt;dateStr非必需&lt;/li&gt;
          &lt;li&gt;dateStr为空，则创建的对象自动获取当前时间和日期&lt;/li&gt;
          &lt;li&gt;dateStr格式
            &lt;ul&gt;
              &lt;li&gt;‘月/日／年’，如7/8/2016&lt;/li&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // &quot;2016/7/8 上午12:00:00&quot;
  new Date('7/8/2016 ').toLocaleString();
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
            &lt;ul&gt;
              &lt;li&gt;‘英文月名 日,年’，如July 8,2016&lt;/li&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // &quot;2016/7/8 上午12:00:00&quot;
  new Date('July 8,2016').toLocaleString();
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
            &lt;ul&gt;
              &lt;li&gt;‘英文星期几 英文月名 日 年 时:分:秒 时区’,如Fri July 8 2016 11:00:00&lt;/li&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // &quot;2016/7/8 上午11:00:00&quot;
  new Date('Friday July 8 2016 11:00:00').toLocaleString();
  // &quot;2016/7/8 上午12:00:00&quot;
  new Date('Friday July 8 2016').toLocaleString();
  // &quot;2016/7/8 上午11:00:00&quot;
  new Date('Friday July 8 2016 11:00').toLocaleString();
  // &quot;2001/7/8 上午12:00:00&quot;
  new Date('Friday July 8').toLocaleString();
  // &quot;2016/7/8 上午11:00:00&quot;
  new Date('July 8 2016 11:00').toLocaleString();
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
            &lt;ul&gt;
              &lt;li&gt;ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss.sssZ(例如2004-05-25T00:00:00)
                &lt;ul&gt;
                  &lt;li&gt;只有兼容es5的实现格式支持.&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;备注
            &lt;ul&gt;
              &lt;li&gt;如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()&lt;/li&gt;
              &lt;li&gt;日期对象在不同浏览器中的实现有许多奇怪的行为.
                &lt;ul&gt;
                  &lt;li&gt;chrome对于’-‘和’/’分割日期的形式都是支持的，能够返回正确的毫秒数或者时间格式;safari仅对’/’分割日期的形式支持，对’-‘分割日期的形式并不支持。&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;所有日期都是基于系统设置的本地时间创建的.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;date原型方法&quot;&gt;Date原型方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Date.prototype.tolSOString
    &lt;ul&gt;
      &lt;li&gt;定义: 返回一个ISO格式的字符串:YYYY-MM-DDTHH:mm:ss.sssZ.时区总是UTC(协调世界时)，加一个后缀“Z”标识。&lt;/li&gt;
      &lt;li&gt;语法: dateObj.toISOString()&lt;/li&gt;
      &lt;li&gt;Demo
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 		var d = new Date();
  d.toISOString();
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Date.prototype.toJSON
    &lt;ul&gt;
      &lt;li&gt;定义: 返回Date对象的字符串形式。&lt;/li&gt;
      &lt;li&gt;语法: 调用toJSON()返回一个JSON格式字符串(使用toISOString())，表示该日期对象的值。&lt;/li&gt;
      &lt;li&gt;备注: Date.prototype.toJSON.call(new Date(NaN))返回null&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Date.prototype.now
    &lt;ul&gt;
      &lt;li&gt;定义: 返回表示调用这个方法时的日期和时间的毫秒数&lt;/li&gt;
      &lt;li&gt;语法: Date.now()&lt;/li&gt;
      &lt;li&gt;备注&lt;/li&gt;
      &lt;li&gt;now()是Date的一个静态函数&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;兼容性处理&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime();
    };
  }
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;日期格式化方法&quot;&gt;日期格式化方法&lt;/h3&gt;
&lt;p&gt;将日期格式化为字符串的方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;toDateString
    &lt;ul&gt;
      &lt;li&gt;定义: 以特定于实现的格式显示星期几、月、日和年(把Date对象的日期部分转换为字符串)&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  document.write(d.toDateString());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;toTimeString
    &lt;ul&gt;
      &lt;li&gt;定义: 以特定于实现的格式显示时、分、秒和时区(把Date对象的时间部分转换为字符串，并返回结果)&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  document.write(d.toTimeString());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;toLocaleDateString
    &lt;ul&gt;
      &lt;li&gt;定义: 以特定于地区的格式显示星期几、月、日和年(可根据本地时间把Date对象的日期部分转换为字符串，并返回结果)&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  document.write(d.toLocaleDateString());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;toLocaleTimeString
    &lt;ul&gt;
      &lt;li&gt;定义: 以特定于地区的格式显示时、分、秒和时区(可根据本地时间把Date对象的时间部分转换为字符串，并返回结果)&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  document.write(d.toLocaleTimeString());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;toUTCString
    &lt;ul&gt;
      &lt;li&gt;定义: 以特定于实现的格式完整的UTC日期(可根据世界时UTC把Date对象转换为字符串，并返回结果)&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  document.write(d.toLocaleTimeString());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;toLocaleString和toString方法一样
&lt;strong&gt;以上这些字符串格式方法的输出也是因浏览器而异的&lt;/strong&gt;
    &lt;h3 id=&quot;date对象方法&quot;&gt;Date对象方法&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;getTime
    &lt;ul&gt;
      &lt;li&gt;定义: 返回表示日期的毫秒数，与valueOf()方法返回值相同&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getTime()&lt;/li&gt;
      &lt;li&gt;注意点: 返回的毫秒数是距1970年1月1日午夜(GMT 时间)之间的毫秒数&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var minutes = 1000*60;
  var hours = minutes*60;
  var days = hours*24;	
  var years = days*365;
  var d = new Date();	
  var t = d.getTime();
  var y = t/years;
  document.write(&quot;It's been: &quot; + y + &quot; years since 1970/01/01!&quot;);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setTime
    &lt;ul&gt;
      &lt;li&gt;定义: 以毫秒设置日期会改变整个日期.&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setTime(millisec)
        &lt;ul&gt;
          &lt;li&gt;millisec: 必须，要设置的日期和时间据GMT时间1970年1月1日午夜之间的毫秒数&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注: 返回参数 millisec&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var date = new Date('7/6/2016');
  date.setTime('1467948764748');
  // &quot;2016/7/8&quot;
  date.toLocaleDateString();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getFullYear
    &lt;ul&gt;
      &lt;li&gt;定义: 取得4位数的年份(如2016而不是16)&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getFullYear()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  document.write(d.getFullYear());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getUTCFullYear
    &lt;ul&gt;
      &lt;li&gt;定义: 返回UTC(世界时)日期的4位年份&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  document.write(d.getUTCFullYear());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setFullYear
    &lt;ul&gt;
      &lt;li&gt;定义: 设置日期的年份&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setFullYear(year,month,day)
        &lt;ul&gt;
          &lt;li&gt;year,必须,传入的年份数字必须是四位(如2016而不是16)。&lt;/li&gt;
          &lt;li&gt;month,可选,表示月份的数值,介于0～11之间&lt;/li&gt;
          &lt;li&gt;day,可选,表示月中某一天的数值,介于1～31之间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注: 调整过的日期的毫秒表示&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var date = new Date('7/8/2016');
  date.setFullYear('2017');
  // &quot;2017/7/8&quot;
  date.toLocaleDateString();
  date.setFullYear(2018);
  // &quot;2018/7/8&quot;
  date.toLocaleDateString();
  var d = new Date();
  d.setFullYear(1992,10,3);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;注意点: 传入参数可以是number型也可以是string型(可转换为有效数字);&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;setUTCFullYear
    &lt;ul&gt;
      &lt;li&gt;定义: 设置UTC日期的年份&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setUTCFullYear(year,month,day)
        &lt;ul&gt;
          &lt;li&gt;year,必须,传入的年份数字必须是四位(如2016而不是16)。&lt;/li&gt;
          &lt;li&gt;month,可选,表示月份的数值,介于0～11之间&lt;/li&gt;
          &lt;li&gt;day,可选,表示月中某一天的数值,介于1～31之间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;参数: 年(数字),传入的年份数字必须是四位(如2016而不是16)&lt;/li&gt;
      &lt;li&gt;备注: 调整过的日期的毫秒表示&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var date = new Date('7/6/2016');
  date.setUTCFullYear('2017');
  // &quot;2017/7/6&quot;
  date.toLocaleDateString();
  date.setUTCFullYear(2018);
  // &quot;2018/7/6&quot;
  date.toLocaleDateString();
  var d = new Date();
  d.setUTCFullYear(1992,10,3);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getMonth
    &lt;ul&gt;
      &lt;li&gt;定义: 返回日期中的月份数字，其中0表示一月，11表示十二月&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getMonth()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d=new Date();
  var month=new Array(12);
  month[0]=&quot;January&quot;;
  month[1]=&quot;February&quot;;
  month[2]=&quot;March&quot;;
  month[3]=&quot;April&quot;;
  month[4]=&quot;May&quot;;
  month[5]=&quot;June&quot;;
  month[6]=&quot;July&quot;;
  month[7]=&quot;August&quot;;
  month[8]=&quot;September&quot;;
  month[9]=&quot;October&quot;;
  month[10]=&quot;November&quot;;
  month[11]=&quot;December&quot;;
  document.write(&quot;The month is &quot; + month[d.getMonth()]);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getUTCMonth
    &lt;ul&gt;
      &lt;li&gt;定义: 返回UTC日期中的月份数字，其中0表示一月，11表示十二月&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getUTCMonth()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d=new Date();
  var month=new Array(12);
  month[0]=&quot;January&quot;;
  month[1]=&quot;February&quot;;
  month[2]=&quot;March&quot;;
  month[3]=&quot;April&quot;;
  month[4]=&quot;May&quot;;
  month[5]=&quot;June&quot;;
  month[6]=&quot;July&quot;;
  month[7]=&quot;August&quot;;
  month[8]=&quot;September&quot;;
  month[9]=&quot;October&quot;;
  month[10]=&quot;November&quot;;
  month[11]=&quot;December&quot;;
  document.write(&quot;The month is &quot; + month[d.getUTCMonth()]);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setMonth
    &lt;ul&gt;
      &lt;li&gt;定义: 设置日期的月份，传入的月份值必须大于等于0，超过11则增加年份。&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setMonth(month,day)
        &lt;ul&gt;
          &lt;li&gt;month: 必须,一个表示月份的数值.介于0～11之间&lt;/li&gt;
          &lt;li&gt;day: 可选, 一个表示月的某一天的数值,该值介于1~31之间。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注: 返回调整过的日期的毫秒表示。&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d=new Date();
  d.setMonth(0);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setUTCMonth
    &lt;ul&gt;
      &lt;li&gt;定义: 设置UTC日期的月份,传入的月份值必须大于等于0，超过11则增加年份。&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setUTCMonth(month,day)
        &lt;ul&gt;
          &lt;li&gt;month: 必须,该参数是0(一月)~11(十二月)之间的整数&lt;/li&gt;
          &lt;li&gt;day: 可选,在1 ~ 31之间的整数。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d=new Date();
  d.setUTCMonth(0);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getDate
    &lt;ul&gt;
      &lt;li&gt;定义: 返回日期月份中的天数(1～31)&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getDate()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var d = new Date();
  document.write(d.getDate());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getUTCDate
    &lt;ul&gt;
      &lt;li&gt;定义: 返回UTC日期月份中的天数(1～31)&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getUTCDate()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  document.write(d.getUTCDate());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setDate
    &lt;ul&gt;
      &lt;li&gt;定义: 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份.&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setDate(day)
        &lt;ul&gt;
          &lt;li&gt;day: 必需。表示一个月中的一天的一个数值(1~31);&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注: 返回调整过的日期的毫秒&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  d.setDate(15);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setUTCDate
    &lt;ul&gt;
      &lt;li&gt;定义: 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setUTCDate(day)
        &lt;ul&gt;
          &lt;li&gt;day: 必需。表示一个月中的一天的一个数值(1~31);&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demo
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  d.setDate(15);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;getDay
    &lt;ul&gt;
      &lt;li&gt;定义: 返回日期中星期的星期几.其中0表示星期日,6表示星期六&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getDay()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d=new Date();
  var weekday=new Array(7);
  weekday[0]=&quot;Sunday&quot;;
  weekday[1]=&quot;Monday&quot;;
  weekday[2]=&quot;Tuesday&quot;;
  weekday[3]=&quot;Wednesday&quot;;
  weekday[4]=&quot;Thursday&quot;;
  weekday[5]=&quot;Friday&quot;;
  weekday[6]=&quot;Saturday&quot;;
  document.write(&quot;Today it is &quot; + weekday[d.getDay()]);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getUTCDay
    &lt;ul&gt;
      &lt;li&gt;定义: 返回UTC日期中星期的星期几.其中0表示星期日,6表示星期六&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getUTCDay()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d=new Date();
  document.write(d.getUTCDay());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getHours
    &lt;ul&gt;
      &lt;li&gt;定义: 返回日期中的小时数(0~23)&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getHours()&lt;/li&gt;
      &lt;li&gt;备注:返回值是0(午夜)到23(晚上11点)之间的一个整数。&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  document.write(d.getHours());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getUTCHours
    &lt;ul&gt;
      &lt;li&gt;定义: 返回UTC日期中的小时数(0~23)&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getUTCHours()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  document.write(d.getUTCHours());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setHours
    &lt;ul&gt;
      &lt;li&gt;定义: 设置日期中的小时数。传入的值超过23则增加月份中的天数&lt;/li&gt;
      &lt;li&gt;参数: dateObject.setHours(hour,min,sec,millisec)
        &lt;ul&gt;
          &lt;li&gt;hour: 必需。表示小时的数值，介于0(午夜)~23(晚上11点)之间&lt;/li&gt;
          &lt;li&gt;min: 可选。表示分钟的数值，介于0~59之间。&lt;/li&gt;
          &lt;li&gt;sec: 可选。表示秒的数值，介于0~59之间。&lt;/li&gt;
          &lt;li&gt;millisec: 可选。表示毫秒的数值，介于0~999之间。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注: 如果上面的参数之一使用一位的数字来规定，那么 JavaScript 会在结果中加一或两个前置0&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  d.setHours(15,35,1);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setUTCHours
    &lt;ul&gt;
      &lt;li&gt;定义: 设置UTC日期中的小时数。传入的值超过23则增加月份中的天数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setUTCHours(hour,min,sec,millisec)
        &lt;ul&gt;
          &lt;li&gt;hour: 必需。表示小时的数值，介于0(午夜)~23(晚上11点)之间&lt;/li&gt;
          &lt;li&gt;min: 可选。表示分钟的数值，介于0~59之间。&lt;/li&gt;
          &lt;li&gt;sec: 可选。表示秒的数值，介于0~59之间。&lt;/li&gt;
          &lt;li&gt;millisec: 可选。表示毫秒的数值，介于0~999之间。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;如果没有规定min,sec以及millisec参数，则使用从 getUTCMinutes, getUTCSeconds以及getUTCMilliseconds方法返回的值;&lt;/li&gt;
          &lt;li&gt;如果您规定的参数在指定范围之外，则setUTCHours尝试据此来更新Date对象中的日期信息。例如，如果sec参数的值是100，则增加1分钟(min + 1)，而秒数为40。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  d.setUTCHours(23,15,6);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getMinutes
    &lt;ul&gt;
      &lt;li&gt;定义: 返回日期中的分钟数(0到59)&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getMinutes()&lt;/li&gt;
      &lt;li&gt;备注: 由getMinutes()返回的值是一个两位的数字。不过返回值不总是两位的，如果该值小于10，则仅返回一位数字&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  document.write(d.getMinutes());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getUTCMinutes
    &lt;ul&gt;
      &lt;li&gt;定义: 返回日期中的分钟数(0到59)&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getUTCMinutes()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var born = new Date(&quot;July 21, 1983 01:15:00&quot;);
  document.write(born.getUTCMinutes());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setMinutes
    &lt;ul&gt;
      &lt;li&gt;定义: 设置日期中的分钟数。传入的值超过59则增加小时数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setMinutes(min,sec,millisec)
        &lt;ul&gt;
          &lt;li&gt;min: 必需。表示分钟的数值，介于0 ~ 59之间&lt;/li&gt;
          &lt;li&gt;sec: 可选。表示秒的数值，介于0 ~ 59之间&lt;/li&gt;
          &lt;li&gt;millisec: 可选。表示毫秒的数值，介于0 ~ 999之间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注: 如果上面的参数之一使用一位的数字来规定，那么JavaScript会在结果中加一或两个前置0。&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  d.setMinutes(1);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setUTCMinutes
    &lt;ul&gt;
      &lt;li&gt;定义: 设置UTC日期中的分钟数。传入的值超过59则增加小时数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setUTCMinutes(min,sec,millisec)
        &lt;ul&gt;
          &lt;li&gt;min: 必需。表示分钟的数值，介于0 ~ 59之间&lt;/li&gt;
          &lt;li&gt;sec: 可选。表示秒的数值，介于0 ~ 59之间&lt;/li&gt;
          &lt;li&gt;millisec: 可选。表示毫秒的数值，介于0 ~ 999之间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  d.setUTCMinutes(1);
  document.write(d);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getSeconds
    &lt;ul&gt;
      &lt;li&gt;定义: 返回日期中的秒数(0~59)&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getSeconds()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  document.write(d.getSeconds());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getUTCSeconds
    &lt;ul&gt;
      &lt;li&gt;定义: 返回UTC日期中的秒数(0~59)&lt;/li&gt;
      &lt;li&gt;参数: dateObject.getUTCSeconds()&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var Birthday = new Date(&quot;July 21, 1983 01:15:00&quot;);
  document.write(Birthday.getUTCSeconds());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setSeconds
    &lt;ul&gt;
      &lt;li&gt;定义: 设置日期中的秒数.传入的值超过59会增加分钟数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setSeconds(sec,millisec)
        &lt;ul&gt;
          &lt;li&gt;sec: 必需。表示秒的数值.&lt;/li&gt;
          &lt;li&gt;millisec: 可选。表示毫秒的数值，介于0 ~ 999之间&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  d.setSeconds(1)
  document.write(d)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setUTCSeconds
    &lt;ul&gt;
      &lt;li&gt;定义: 设置UTC日期中的秒数.传入的值超过59会增加分钟数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setUTCSeconds(sec,millisec)&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  d.setSeconds(1)
  document.write(d)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getMilliseconds
    &lt;ul&gt;
      &lt;li&gt;定义: 返回日期中的毫秒数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getMilliseconds()&lt;/li&gt;
      &lt;li&gt;备注: 由getMilliseconds()返回的值是一个三位的数字。不过返回值不总是三位的，如果该值小于 100，则仅返回两位数字，如果该值小于10，则仅返回一位数字。&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date();
  document.write(d.getMilliseconds());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getUTCMilliseconds
    &lt;ul&gt;
      &lt;li&gt;定义: 返回UTC日期中的毫秒数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getUTCMilliseconds()&lt;/li&gt;
      &lt;li&gt;备注: 由getMilliseconds()返回的值是一个三位的数字。不过返回值不总是三位的，如果该值小于 100，则仅返回两位数字，如果该值小于10，则仅返回一位数字。&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  document.write(d.getUTCMilliseconds())
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setMilliseconds
    &lt;ul&gt;
      &lt;li&gt;定义: 设置日期中的毫秒数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setMilliseconds(millisec)
        &lt;ul&gt;
          &lt;li&gt;millisec: 必需。用于设置 dateObject 毫秒字段，该参数是介于 0 ~ 999 之间的整数。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  d.setMilliseconds(1)
  document.write(d)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;setUTCMilliseconds
    &lt;ul&gt;
      &lt;li&gt;定义: 设置UTC日期中的毫秒数&lt;/li&gt;
      &lt;li&gt;语法: dateObject.setUTCMilliseconds(millisec)
        &lt;ul&gt;
          &lt;li&gt;millisec: 必需。要给dateObject设置的毫秒字段的值.该参数是 0 ~ 999 之间的整数&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var d = new Date()
  d.setUTCMilliseconds(1)
  document.write(d)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;getTimezoneOffset
    &lt;ul&gt;
      &lt;li&gt;定义: 返回本地时间与UTC时间相差的分钟数.在某地进入夏令时的情况下，这个值会有所变化。&lt;/li&gt;
      &lt;li&gt;语法: dateObject.getTimezoneOffset()&lt;/li&gt;
      &lt;li&gt;备注: 由于使用夏令时的惯例，该方法的返回值不是一个常量&lt;/li&gt;
      &lt;li&gt;Demo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var gmtHours = d.getTimezoneOffset()/60
  document.write(&quot;The local time zone is: GMT &quot; + gmtHours)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ecmascript6&quot;&gt;ECMAScript6&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Invalid Date&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return new Date(NaN) + &quot;&quot; === &quot;Invalid Date&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;参考文章&quot;&gt;参考文章&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3school.com.cn/jsref/jsref_obj_date.asp&quot;&gt;W3C&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://vdisk.weibo.com/s/ubioot-jTQHGD&quot;&gt;Js高级程序设计&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/date/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/date/</guid>
        
        <category>JS</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>weakSet与WeakMap简介</title>
        <description>&lt;h1 id=&quot;weakset&quot;&gt;WeakSet&lt;/h1&gt;
&lt;h2 id=&quot;weakset与set&quot;&gt;WeakSet与Set&lt;/h2&gt;
&lt;h3 id=&quot;相同-不重复的值的集合&quot;&gt;相同: 不重复的值的集合&lt;/h3&gt;
&lt;h3 id=&quot;不同&quot;&gt;不同&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WeakSet的成员只能是对象&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var ws = new WeakSet();
ws.add(1);  // TypeError: Invalid value used in weak set
ws.add(Symbol()); // Uncaught TypeError: Invalid value used in weak set
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用
    &lt;ul&gt;
      &lt;li&gt;如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存。&lt;/li&gt;
      &lt;li&gt;无法引用WeakSet的成员，因此WeakSet是不可遍历的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;weakset使用与方法&quot;&gt;WeakSet使用与方法&lt;/h2&gt;
&lt;h3 id=&quot;创建&quot;&gt;创建&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。&lt;code class=&quot;highlighter-rouge&quot;&gt;var ws = new WeakSet();
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;WeakSet可以接受一个数组或类似数组的对象作为参数。该数组的所有成员，都会自动成为WeakSet实例对象的成员(任何具有iterable接口的对象，都可以作为WeakSet的参数)。&lt;strong&gt;WeakSet的弱引用如何测试？&lt;/strong&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = [[1,2], [3,4]];
var ws = new WeakSet(a);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;WeakSet的成员是数组成员，而不是数组本身。这意味着，数组的成员只能是对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var b = [3, 4];
var ws = new WeakSet(b);  // Uncaught TypeError: Invalid value used in weak set
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;方法&quot;&gt;方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WeakSet.prototype.add(value): 向WeakSet实例添加一个新成员。&lt;/li&gt;
  &lt;li&gt;WeakSet.prototype.delete(value): 清除WeakSet实例的指定成员。返回boolean表示是否成功。&lt;/li&gt;
  &lt;li&gt;WeakSet.prototype.has(value): 返回一个布尔值，表示某个值是否存在于WeakSet实例中。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var ws = new WeakSet();
var obj = {};
var foo = {};
ws.add(window);
ws.add(obj);
console.log(ws.has(window)); // true
console.log(ws.has(foo));    // false
console.log(ws.delete(window));  // true
console.log(ws.has(window));    // false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;特性&quot;&gt;特性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WeakSet没有size属性，没有办法遍历它的成员.
    &lt;ul&gt;
      &lt;li&gt;WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var ws = new WeakSet();
console.log(ws.size);   // undefined
console.log(ws.forEach);  // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。&lt;strong&gt;查下如何防止内存消失，啥是内存泄漏&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;weakmap&quot;&gt;WeakMap&lt;/h1&gt;
&lt;h2 id=&quot;weakmap与map区别&quot;&gt;WeakMap与Map区别&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;它只接受对象作为键名(null除外)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var map = new WeakMap()
map.set(1, 2);  // Uncaught TypeError: Invalid value used as weak map key
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;键名所指向的对象不计入垃圾回收机制(弱引用)，其所对应的对象可能会被自动回收，当对象被回收后,WeakMap自动移除对应的键值对.&lt;/li&gt;
  &lt;li&gt;当对象被回收后，WeakMap自动移除对应的键值对。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;weakmap使用场合与目的&quot;&gt;WeakMap使用场合与目的&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。&lt;/li&gt;
  &lt;li&gt;WeakMap结构有助于防止内存泄漏&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 这demo怎么测试呀?好头疼
var wm = new WeakMap();
var element = document.getElementById('spchx');
wm.set(element, &quot;Original&quot;);
wm.get(element);  // &quot;Original&quot;
element.parentNode.removeChild(element);
var temp = element;
element = null;
wm.get(temp); // &quot;Original&quot;

// 使用Map
var wm = new Map();
var element = document.getElementsByTagName(&quot;div&quot;);
wm.set(element, &quot;Original&quot;);
console.log(wm.get(element)); // &quot;Original&quot;
var temp = element;
element = null;
wm.get(temp); // 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;weakmap特性与应用&quot;&gt;WeakMap特性与应用&lt;/h2&gt;
&lt;h3 id=&quot;基本特性&quot;&gt;基本特性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;没有遍历操作(没有key()、values()、entries()方法，也没有size属性)&lt;/li&gt;
  &lt;li&gt;无法清空,即不支持clear方法.
    &lt;ul&gt;
      &lt;li&gt;这与WeakMap的键不被计入引用，被垃圾回收机制忽略有关。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WeakMap只有四个方法:get()、set()、has()、delete()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;典型应用&quot;&gt;典型应用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WeakMap应用的典型场合就是DOM节点作为键名。&lt;/li&gt;
  &lt;li&gt;WeakMap的另一个用处是部署私有属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let myElement = document.getElementById('logo-sub');
let myWeakmap = new WeakMap();

myWeakmap.set(myElement, {timesClicked: 0});

myElement.addEventListener('click', function() {
  let logoData = myWeakmap.get(myElement);
  logoData.timesClicked++;
  myWeakmap.set(myElement, logoData);
}, false);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management&quot;&gt;内存管理&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/WeakSet/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/WeakSet/</guid>
        
        <category>ES6</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>Iterator简介</title>
        <description>&lt;h1 id=&quot;iterator&quot;&gt;Iterator&lt;/h1&gt;
&lt;h2 id=&quot;iterator遍历器的概念&quot;&gt;Iterator(遍历器)的概念&lt;/h2&gt;
&lt;p&gt;遍历器(Iterator)是一种接口，为各种不同的数据结构提供统一的访问机制。&lt;/p&gt;

&lt;h3 id=&quot;iterator的作用&quot;&gt;Iterator的作用&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;为各种数据结构提供一个统一的、简便的访问接口&lt;/li&gt;
  &lt;li&gt;使得数据结构的成员能够按某种次序排列&lt;/li&gt;
  &lt;li&gt;ES6创造了一种新的遍历命令(for…of循环)，Iterator结构主要提供for…of使用&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;iterator的遍历过程&quot;&gt;Iterator的遍历过程&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个指针对象，指向当前数据结构的起始位置(即遍历器对象本质是一个指针对象)&lt;/li&gt;
  &lt;li&gt;第一次调用用指针对象的next方法，可以将指针指向数据结构的第一个成员
    &lt;ul&gt;
      &lt;li&gt;返回成员格式为包含value和done两个属性的对象。其中value是当前成员的值，done属性是布尔值，标示遍历是否结束。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二次调用指针对象的next方法，可以将指针指向数据结构的第二个成员&lt;/li&gt;
  &lt;li&gt;不断调用指针对象的next方法，直到它指向数据结构的结束位置&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 模拟next方法返回值
var it = makeIterator(['a', 'b']);
it.next() // { value: &quot;a&quot;, done: false }
it.next() // { value: &quot;b&quot;, done: false }
it.next() // { value: undefined, done: true }
function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex &amp;lt; array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true};
    }
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;备注&quot;&gt;备注:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于遍历器对象来说，done: false和value: undefined属性都是可以省略的&lt;/li&gt;
  &lt;li&gt;在ES6中，有些数据结构原生具备Iterator接口(比如数组)，即不用任何处理，就可以被for…of循环遍历，有些就不行(比如对象)
    &lt;ul&gt;
      &lt;li&gt;原生具备Iterator接口的是因为这些数据结构原生部署了Symbol.iterator属性&lt;/li&gt;
      &lt;li&gt;凡是部署了Symbol.iterator属性的数据结构就称为部署了遍历器接口，调用这个接口就会返回一个遍历器对象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据结构的默认iterator接口&quot;&gt;数据结构的默认Iterator接口&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环。&lt;/li&gt;
  &lt;li&gt;当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口&lt;/li&gt;
  &lt;li&gt;ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，即一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）&lt;/li&gt;
  &lt;li&gt;Symbol.iterator本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内（请参考Symbol一章）&lt;/li&gt;
  &lt;li&gt;调用Symbol.iterator方法，就会得到当前数据结构默认的遍历器生成函数&lt;/li&gt;
  &lt;li&gt;在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象(arguments和NodeList等)、Set和Map结构&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = ['a', 'b', 'c'];
// arr数组具有遍历器接口，部署在arr的Symbol.iterator属性上
let iter = arr[Symbol.iterator]();
iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;原生部署Iterator接口的三类数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们&lt;/li&gt;
  &lt;li&gt;其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。&lt;/li&gt;
  &lt;li&gt;对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的&lt;/li&gt;
  &lt;li&gt;本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换&lt;/li&gt;
  &lt;li&gt;一个对象如果要有可被for…of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可以）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 类部署Iterator接口的写法。
class RangeIterator{
    constructor(start, stop){
        this.value = start;
        this.stop = stop;
    }
    // Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象
    [Symbol.iterator](){ return this; }
    next(){
        var value = this.value;
        if( value &amp;lt; this.stop ){
            this.value ++;
            return {done: false, value: value };
        } else {
            return { done : true, value: undefined };
        }
    }
}
function range(start, stop) {
    return new RangeIterator(start, stop);
}
for(var value of range(0, 3)){
    console.log(value); //依次输出0，1，2
}
// 通过遍历器实现指针结构
function Obj(value){
    this.value = value;
    this.next = null;
}
Obj.prototype[Symbol.iterator] = function(){
    var iterator = {
        next: next
    };
    var current = this;
    function next(){
        if (current) {
            var value = current.value;
            current = current.next;
            return {
                done: false,
                value: value
            }
        } else {
            return {
                done : true
            };
        }
    }
    return iterator;
};
var one = new Obj(1);
var two = new Obj(2);
var three = new Obj(3);
one.next = two;
two.next = three;
for(var i of one){
    console.log(i); // 依次输出1，2，3，undefined
}
// 为对象添加Iterator接口
let obj = {
    data: ['hello', 'world'],
    [Symbol.iterator](){
        const self = this;
        let index = 0;
        return {
            next(){
                if(index &amp;lt; self.data.length){
                    return {
                        value: self.data[index++],
                        done: false
                    }
                } else {
                    return { value: undefined, done: true };
                }
            }
        }
    }
};
for(o of obj){
    console.log(o); // 依次输出hello、world、undefined
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对于类似数组的对象，部署Iterator接口，使用Symbol.iterator方法直接引用数组的Iterator接口&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
// 或者
NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];
// 类数组对象调用数组的Symbol.iterator方法
let iterable = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
  [Symbol.iterator]: Array.prototype[Symbol.iterator]
};
for (let item of iterable) {
  console.log(item); // 'a', 'b', 'c'
}
// 若没有[Symbol.iterator]属性，则会报错
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;注意普通对象部署数组的Symbol.iterator方法，并无效果&lt;/li&gt;
  &lt;li&gt;如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var obj = {};
obj[Symbol.iterator] = () =&amp;gt; 1;
[...obj] // TypeError: obj[Symbol.iterator] is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;有了遍历器接口，数据结构就可以用for…of循环遍历，也可以使用while循环遍历&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var $iterator = ITERABLE[Symbol.iterator]();
var $result = $iterator.next();
while (!$result.done) {
  var x = $result.value;
  // ...
  $result = $iterator.next();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;调用iterator接口的场合&quot;&gt;调用Iterator接口的场合&lt;/h2&gt;

&lt;p&gt;一些场合会默认调用Iterator接口（即Symbol.iterator方法）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解构赋值:对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let set = new Set().add('a').add('b').add('c');
let [x,y] = set;   // x='a'; y='b'
let [first, ...rest] = set;  //first:&quot;a&quot;;rest:[&quot;b&quot;, &quot;c&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;扩展运算符: 扩展运算符（…）也会调用默认的iterator接口
    &lt;ul&gt;
      &lt;li&gt;可以将任何部署了Iterator接口的数据结构，转为数组&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var str = 'hello';
[...str]; //  ['h','e','l','l','o']
let arr = ['b', 'c'];
['a', ...arr, 'd']; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;yield* :yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let generator = function* () {
  yield 1;
  yield* [2,3,4];
  yield 5;
};
var iterator = generator();
iterator.next() // { value: 1, done: false }
iterator.next() // { value: 2, done: false }
iterator.next() // { value: 3, done: false }
iterator.next() // { value: 4, done: false }
iterator.next() // { value: 5, done: false }
iterator.next() // { value: undefined, done: true }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;其他场合:由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口
    &lt;ul&gt;
      &lt;li&gt;for…of&lt;/li&gt;
      &lt;li&gt;Array.from()&lt;/li&gt;
      &lt;li&gt;Map(),Set(),WeakMap(),WeakSet()&lt;/li&gt;
      &lt;li&gt;Promise.all()&lt;/li&gt;
      &lt;li&gt;Promise.race()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;字符串的iterator接口&quot;&gt;字符串的Iterator接口&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;字符串是一个类似数组的对象，也原生具有Iterator接口&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var someString = &quot;hi&quot;;
typeof someString[Symbol.iterator];   // &quot;function&quot;
var iterator = someString[Symbol.iterator]();
iterator.next()  // { value: &quot;h&quot;, done: false }
iterator.next()  // { value: &quot;i&quot;, done: false }
iterator.next()  // { value: undefined, done: true }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var str = new String(&quot;hi&quot;);
[...str] // [&quot;h&quot;, &quot;i&quot;]
str[Symbol.iterator] = function() {
  return {
    next: function() {
      if (this._first) {
        this._first = false;
        return { value: &quot;bye&quot;, done: false };
      } else {
        return { done: true };
      }
    },
    _first: true
  };
};
[...str] // [&quot;bye&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;iterator接口与generator函数&quot;&gt;Iterator接口与Generator函数&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Symbol.iterator方法的最简单实现,使用Generator函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 使用generator
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
[...myIterable] // [1, 2, 3]
// 简写
let obj = {
  * [Symbol.iterator]() {
    yield 'hello';
    yield 'world';
  }
};
for (let x of obj) {
  console.log(x); // 依次输出hello,world
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;遍历器对象的return和throw方法&quot;&gt;遍历器对象的return()和throw()方法&lt;/h2&gt;
&lt;p&gt;如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。&lt;/p&gt;

&lt;h3 id=&quot;return&quot;&gt;return&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用场合
    &lt;ul&gt;
      &lt;li&gt;如果for…of循环提前退出(通常是因为出错，或者有break语句或continue语句)，就会调用return方法。&lt;/li&gt;
      &lt;li&gt;如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;备注: return方法必须返回一个对象.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let obj = {
    data: ['hello', 'world'],
    [Symbol.iterator](){
        const self = this;
        let index = 0;
        return {
            next(){
                if(index &amp;lt; self.data.length){
                    return {
                        value: self.data[index++],
                        done: false
                    }
                } else {
                    return { value: undefined, done: true };
                }
            },
            return(){
                console.log('return');
                return { done: true };
            }
        }
    }
};
for(o of obj){
    console.log(o); // 依次输出hello、return
    break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;throw&quot;&gt;throw&lt;/h3&gt;
&lt;p&gt;throw方法主要是配合Generator函数使用，一般的遍历器对象用不到这个方法&lt;/p&gt;

&lt;h2 id=&quot;forof循环&quot;&gt;for…of循环&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;for…of循环内部调用的是数据结构的Symbol.iterator方法&lt;/li&gt;
  &lt;li&gt;for…of循环可以使用的范围包括数组、Set和Map结构、类数组对象(arguments对象、DOM NodeList对象)、Generator对象、字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数组&quot;&gt;数组&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;数组原生具备iterator接口，for…of循环本质上就是调用这个接口产生的遍历器&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const arr = ['red', 'green', 'blue'];
let iterator  = arr[Symbol.iterator]();
for(let v of arr) {
  console.log(v); // red green blue
}
// 同上for...of方法
for(let v of iterator) {
  console.log(v); // red green blue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for…of循环可以代替数组实例的forEach方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const arr = ['red', 'green', 'blue'];
arr.forEach(function (element, index) {
  console.log(element); // red green blue
  console.log(index);   // 0 1 2
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值
    &lt;ul&gt;
      &lt;li&gt;for…in循环读取键名&lt;/li&gt;
      &lt;li&gt;for…of循环读取键值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = ['a', 'b', 'c', 'd'];
for (let a in arr) {
  console.log(a); // 0 1 2 3
}
for (let a of arr) {
  console.log(a); // a b c d
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = [3, 5, 7];
arr.foo = 'hello';
for (let i in arr) {
  console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;
}
for (let i of arr) {
  console.log(i); //  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;set和map结构&quot;&gt;Set和Map结构&lt;/h3&gt;
&lt;p&gt;Set和Map结构也原生具有Iterator接口，可以直接使用for…of循环&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);
for (var e of engines) {
  console.log(e);  // Gecko，Trident，Webkit
}
var es6 = new Map();
es6.set(&quot;edition&quot;, 6);
es6.set(&quot;committee&quot;, &quot;TC39&quot;);
es6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);
for (var [name, value] of es6) {
  console.log(name + &quot;: &quot; + value); // edition: 6;committee: TC39;standard: ECMA-262
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;遍历的顺序是按照各个成员被添加进数据结构的顺序&lt;/li&gt;
  &lt;li&gt;Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;类似数组的对象&quot;&gt;类似数组的对象&lt;/h3&gt;
&lt;h4 id=&quot;dom-nodelist&quot;&gt;DOM NodeList&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//  DOM NodeList对象
let h3s = document.querySelectorAll(&quot;h3&quot;);
for (let h of h3s) {
   h.style.color = 'red';
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;arguments&quot;&gt;arguments&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// arguments对象
function printArgs() {
  for (let x of arguments) {
    console.log(x);
  }
}
printArgs('a', 'b');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并不是所有的类数组对象都具有iterator接口，因此最简单的方法就是使用Array.from方法将其转换为数组&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arrayLike = { length: 2, 0: 'a', 1: 'b' };
// 报错
for (let x of arrayLike) {
  console.log(x);
}
// 正确
for (let x of Array.from(arrayLike)) {
  console.log(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;对象&quot;&gt;对象&lt;/h3&gt;
&lt;p&gt;对于普通对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var someObject = {
  edition: 6,
  committee: &quot;TC39&quot;,
  standard: &quot;ECMA-262&quot;
};
for (var key of Object.keys(someObject)) {
  console.log(key + &quot;: &quot; + someObject[key]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;部分特殊对象可以将数组的Symbol.iterator属性直接赋值给其Symbol.iterator属性&lt;/li&gt;
  &lt;li&gt;使用Generator函数将对象重新包装&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function* entries(someObject) {
  for (let key of Object.keys(someObject)) {
    yield [key, someObject[key]];
  }
}
for (let [key, value] of entries(someObject)) {
  console.log(key, &quot;-&amp;gt;&quot;, value);
  //edition -&amp;gt; 6; committee -&amp;gt; TC39;standard -&amp;gt; ECMA-262
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;与其它遍历语法的比较&quot;&gt;与其它遍历语法的比较&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;for: 比较麻烦&lt;/li&gt;
  &lt;li&gt;forEach: 中途无法跳出forEach循环，break或者return命令失效&lt;/li&gt;
  &lt;li&gt;for…in:只能遍历数组得到键名,for…in循环主要是为遍历对象而设计
    &lt;ul&gt;
      &lt;li&gt;数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等&lt;/li&gt;
      &lt;li&gt;for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键&lt;/li&gt;
      &lt;li&gt;某些情况下，for…in循环会以任意顺序遍历键名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;for…of
    &lt;ul&gt;
      &lt;li&gt;有着同for…in一样的简洁语法&lt;/li&gt;
      &lt;li&gt;不同用于forEach方法，它可以与break、continue和return配合使用。&lt;/li&gt;
      &lt;li&gt;提供了遍历所有数据结构的统一操作接口&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;参考文献&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/iterator&quot;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/Iterator/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/Iterator/</guid>
        
        <category>ES6</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>ES6-let学习</title>
        <description>&lt;h1 id=&quot;let&quot;&gt;let&lt;/h1&gt;
&lt;h2 id=&quot;let命令&quot;&gt;let命令&lt;/h2&gt;
&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ES6新增命令，用于声明变量。用法类似var，但是其声明变量只在let命令所在代码块有效。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;aLet&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bVar&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;2;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;console.log(aLet);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Uncaught&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ReferenceError:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;aLet&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;defined(…)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;console.log(bVar);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;for循环计数器很适合let命令&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  for (let i = 0; i &amp;lt; 3; i++) {}
  console.log(i);  // Uncaught ReferenceError: i is not defined(…)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考考你?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 使用var变量
  var a = [];
  for (var i = 0; i &amp;lt; 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
  a[6]();    // ?结果
    
  // 使用let变量
  var a = [];
  for (let ii = 0; ii &amp;lt; 10; ii++) {
    a[ii] = function () {
      console.log(ii);
    };
  }
  a[6]();    // ?结果 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;不存在变量提升&quot;&gt;不存在变量提升&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;变量提升:javascript是解释型语言，执行基本分为两个阶段，编译期(预编译)与运行期。在预编译阶段，它是用函数来划分作用域，然后逐层为其以var声明的变量(var变量)与函数定义开辟内存空间，再然后对var变量进行特殊处理，统统赋初始值为undefined。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  (function(){
    var str1 = &quot;1&quot;;
    var fun1 = function(){};
    var str2 = &quot;2&quot;;
    var str3 = &quot;3&quot;;
  })();
  // 同上代码
  (function(){
    var str1,fun1,str2,str3;
    str1 = &quot;1&quot;;
    fun1 = function(){};
    str2 = &quot;2&quot;;
    str3 = &quot;3&quot;;
  })();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;let不会发生’变量提升’，因此，变量一定要在声明后使用，否则报错。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  console.log(foo); // undefined
  console.log(bar); // Uncaught ReferenceError: bar is not defined(…)
  var foo = 2;
  let bar = 2;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;暂时性死区&quot;&gt;暂时性死区&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;考考你?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 使用var
  var tmp = 123;
  if (true) {
    console.log(tmp);
    var tmp;
  }
  // 使用let,运行结果
  var tmp = 123;
  if (true) {
    console.log(tmp);
    let tmp;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”(temporal dead zone，简称TDZ).&lt;/li&gt;
  &lt;li&gt;ES6明确规定，区块中使用let和const声明变量，则会形成封闭作用域，在声明之前使用变量会报错。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考考你?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 未使用let语句
  typeof myData;  
        
  // 使用let语句
  {
      typeof myData;
      let myData = 'myData';
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;h3 id=&quot;不允许重复声明&quot;&gt;不允许重复声明&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;let不允许在相同作用域内，重复声明同一个变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Uncaught SyntaxError: Unexpected token
  function fun1() {
      let num1 = 10;
      var num1 = 1;
  }
  // Uncaught SyntaxError: Unexpected token
  function fun2() {
      let num2 = 10;
      let num2 = 1;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不能在函数内部重新声明参数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function func(arg) {
    let arg; // 报错
  }
  function func(arg) {
    {
      let arg; // 不报错
    }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;h2 id=&quot;块级作用域&quot;&gt;块级作用域&lt;/h2&gt;
    &lt;h3 id=&quot;es5全局作用域和函数作用域&quot;&gt;ES5全局作用域和函数作用域&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考考你?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 场景一
  var date = new Date();
  function fun() {
    console.log(date);
    if (false) {
      var date = &quot;hello world&quot;;
    }
  }
  fun();
        
  // 场景二
  var str = 'hello';
  for (var j = 0; j &amp;lt; str.length; j++) {
    console.log(str[j]);
  }
  console.log(j);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;问题总结:ES5只有全局作用域和函数作用域，没有块级作用域
    &lt;ul&gt;
      &lt;li&gt;内层变量可能会覆盖外层变量&lt;/li&gt;
      &lt;li&gt;用来计数的循环变量泄露为全局变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;es6块级作用域&quot;&gt;ES6块级作用域&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;let实际上为JavaScript新增了块级作用域.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ES6允许块级作用域的任意嵌套,外层作用域无法读取内层作用域的变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;insane&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'Hello&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;World'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;console.log(insane);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Uncaught&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ReferenceError:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;insane&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;defined&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内层作用域可以定义外层作用域的同名变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;insane&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'Hello&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;World';&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{let&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;insane&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'Hello&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;World'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;块级作用域的出现，使得获得立即执行匿名函数（IIFE）不再必要.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // IIFE写法
  (function () {
    var tmp = ...;
    ...
  }());
        
  // 块级作用域写法
  {
    let tmp = ...;
    ...
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;块级作用域与函数声明&quot;&gt;块级作用域与函数声明&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明
    &lt;ul&gt;
      &lt;li&gt;浏览器支持在块级作用域中声明函数,因此上面代码可以正常运行,但是在‘严格模式’下会报错&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 情况一
  if (true) {
    function fun() {}
  }
        
  // 情况二
  try {
    function fun() {}
  } catch(e) {
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ES6引入了块级作用域，明确允许在块级作用域之中声明函数,并且函数声明语句的行为类似于let，在块级作用域之外不可引用。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // ES6严格模式
  'use strict';
  if (true) {
    function f() {}
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;h1 id=&quot;const&quot;&gt;Const&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;定义: 声明一个只读常量，一旦声明，常量的值就不可能改变.&lt;/li&gt;
  &lt;li&gt;注意点
    &lt;ul&gt;
      &lt;li&gt;const一旦声明变量，就必须立即初始化，不能留到以后赋值；&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const COLOR;  //Uncaught SyntaxError: Missing initializer in const declaration&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;const与let相同特性
        &lt;ul&gt;
          &lt;li&gt;只在声明所在的块级作用域内有效&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if (true) {
        const MAX = 5;
  }
  console.log(MAX);  // Uncaught ReferenceError: MAX is not defined
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;变量不提升&lt;/li&gt;
          &lt;li&gt;存在暂时性死区，只能在声明的位置后面使用&lt;/li&gt;
          &lt;li&gt;不能重复声明&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;复合类型(Object，Array等)的变量，可对其值进行修改，即const的定义保证了变量名指向地址不变。&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Array
  const foo = {};
  foo.prop = 123;
  console.log(foo);
  foo = {}; //Uncaught TypeError: Assignment to constant variable.
		
  // Object
  const arr = [];
  arr.push('Hello'); 
  arr.length = 0;    
  arr = ['World'];  // Uncaught TypeError: Assignment to constant variable  
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用const定义复合型变量达到真正的对象不可变，可以使用Object.freeze()方法冻结对象。&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 冻结对象和属性
  var constantize = (obj) =&amp;gt; {
    Object.freeze(obj);
    Object.keys(obj).forEach( (key, value) =&amp;gt; {
      if ( typeof obj[key] === 'object' ) {
        constantize( obj[key] );
      }
    });
  };
		
  const person = {name: 'penglu', age: 27};
  constantize(person);
  person.name = 'lee'; //无法修改，但是不会报错
  const arr = ['one', 'two'];
  constantize(arr);
  arr.push('three');  // Uncaught TypeError: Can't add property 2, object is not extensible
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;let命令、const命令、class命令声明的全局变量，不属于全局对象的属性
        &lt;ul&gt;
          &lt;li&gt;ES5之中，全局对象的属性与全局变量是等价的。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实例&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  const PI = 3.1415926;
  PI = 123;  // Uncaught TypeError: Assignment to constant variable
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;参考文章&quot;&gt;参考文章&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://m.cnblogs.com/57731/1551270.html?full=1&quot;&gt;变量作用域&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/?search=generator&amp;amp;x=0&amp;amp;y=0#docs/let&quot;&gt;ES6入门&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/ES6-let/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/ES6-let/</guid>
        
        <category>ES6</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>ES6-Module学习</title>
        <description>&lt;h1 id=&quot;module&quot;&gt;Module&lt;/h1&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ES6的Class只是面向对象编程的语法糖，升级了ES5构造函数原型继承的写法，并没有解决模块化的问题。&lt;/li&gt;
  &lt;li&gt;Js一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单方法拼装起来，因此对开发大型的、复杂项目形成障碍。&lt;/li&gt;
  &lt;li&gt;es6之前，模块化加载方案，主要有COmmonJS(用于服务器)和AMD(用于浏览器)两种.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;产生&quot;&gt;产生&lt;/h2&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;运行时加载: 整体加载一个模块(即加载所有方法)，生成一个对象，然后从对象上读取方法。&lt;/li&gt;
  &lt;li&gt;编译时加载: 从模块中加载需要使用的方法，其它方法都不加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;与传统模块化方法的区别&quot;&gt;与传统模块化方法的区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;es6实现的模块功能完全取代了现有的COmmonJS和AMD,成为通用的模块解决方案。&lt;/li&gt;
  &lt;li&gt;es6设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，而CommonJS和AMD只能在运行的时候确定。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;es6模块不是对象，而是通过export命令显示指定输出的代码，输入时也采用静态命令的形式。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // ES6模块,实质是从fs模块加载3个方法，其他方法不加载
  import { stat, exists, readFile } from 'fs';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;es6在编译时完成模块加载，效率比CommonJS模块的加载方式高，这也导致无法引用ES6模块本身那个，因为它不是对象。&lt;/li&gt;
  &lt;li&gt;es6在编译时加载，使得静态分析成为可能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;模块的优点&quot;&gt;模块的优点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;静态加载；&lt;/li&gt;
  &lt;li&gt;不再需要UMD模块格式(将来浏览器都会支持ES6模块格式)&lt;/li&gt;
  &lt;li&gt;将来浏览器的新API就能用模块格式提供，不必再做成全局变量或navigator对象的属性&lt;/li&gt;
  &lt;li&gt;不再需要对象作为命名空间(比如Math对象)，未来这些功能可以通过模块提供&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;浏览器使用es6模块的语法: &lt;script type=&quot;module&quot; src=&quot;XX.js&quot;&gt;&lt;/script&gt;
    &lt;ul&gt;
      &lt;li&gt;由于type属性为module， 所以浏览器知道这是一个es6模块。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块，因此只能用babel这样的转码器在Node中使用ES6模块。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;特性&quot;&gt;特性&lt;/h2&gt;
&lt;h3 id=&quot;严格模式&quot;&gt;严格模式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ES6模块自动采用严格模式，不管头部有没有加’use strict’&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://xgfe.github.io/Basics/JavaScript/strictMode.html&quot;&gt;严格模式主要限制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;export命令&quot;&gt;export命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;模块功能主要由两个命令构成:export和import。
    &lt;ul&gt;
      &lt;li&gt;export命令用于规定模块的对外接口。&lt;/li&gt;
      &lt;li&gt;import命令用于输入其他模块提供的功能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;export&quot;&gt;export&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;作用:一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。&lt;/li&gt;
  &lt;li&gt;使用
    &lt;ul&gt;
      &lt;li&gt;使用大括号指定所要输出的一组变量
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 方法一:直接export
  export var firstName = 'Michael';
  export var lastName = 'Jackson';
  export var year = 1958;
        
  // 方法二: 使用{}export
  var firstName = 'Michael';
  var lastName = 'Jackson';
  var year = 1958;
  export {firstName, lastName, year};
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;export除了输出变量，还可以输出函数或类
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 对外输出了multiply
  export function multiply(x, y) {
    return x * y;
  };
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;一般情况下export输出的变量就是本来的名字，但可以使用as关键字重命名，并且重命名后可以使用不同的名字输出两次。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function v1() { ... }
  function v2() { ... }
  export {
    v1 as streamV1,
    v2 as streamV2,
    v2 as streamLatestVersion
  };
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。
        &lt;ul&gt;
          &lt;li&gt;它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 报错
  export 1;	
  // 报错
  var m = 1;
  export m;
            
  // 正确写法
  // 写法一
  export var m = 1;
        
  // 写法二
  var m = 1;
  export {m};
            
  // 写法三
  var n = 1;
  export {n as m};
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export var foo = 'bar';
  setTimeout(() =&amp;gt; foo = 'baz', 500);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;export命令可以出现在模块的任何位置。如果处于块级作用域内就会报错，因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;import命令&quot;&gt;import命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;作用:使用export命令定义模块的对外接口后，其他JS文件可以通过import命令加载这个模块(文件)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import {firstName, lastName, year} from './profile';
  function setName(element) {
    element.textContent = firstName + ' ' + lastName;
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;备注
    &lt;ul&gt;
      &lt;li&gt;import的{}里面的变量名必须与被导入模块对外接口(export)的名称相同&lt;/li&gt;
      &lt;li&gt;如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import { lastName as surname } from './profile';
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;import命令具有提升效果，会提升到整个模块的头部，首先执行。&lt;/li&gt;
      &lt;li&gt;如果在一个模块中，先输入后输出同一个模块，import语句可以与export语句写在一起.但从可读性考虑，不建议这种写法。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export { es6 as default } from './someModule';
  // 等同于
  import { es6 } from './someModule';
  export default es6;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;模块的整体加载&quot;&gt;模块的整体加载&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;除了指定加载某个输出值，可以使用整体加载，即用星号(*)指定一个对象，所有输出值都加载在这个对象上面
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // file1.js,导出方法
  export function area(radius) {
    return Math.PI * radius * radius;
  }
  export function circumference(radius) {
    return 2 * Math.PI * radius;
  }
  // file2.js,加载方法
  // 指定加载
  import { area, circumference } from './circle';
  console.log('圆面积：' + area(4));
  console.log('圆周长：' + circumference(14));
  // 整体加载
  import * as circle from './circle';
  console.log('圆面积：' + circle.area(4));
  console.log('圆周长：' + circle.circumference(14));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;export-default命令&quot;&gt;export default命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;以上内容使用inport命令的时候，用户需要知道所有加载的变量名或函数名，否则无法加载。&lt;/li&gt;
  &lt;li&gt;export default命令为模块指定默认输出，不用阅读文档就能加载模块;其他模块加载时,import命令可为该匿名函数指定任意名字。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 默认输出一个函数
  export default function(){
      console.log('default export');
  }
  // 加载默认export文件
  import customName from './export-default';
  customName(); // 'foo'
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export default命令用在非匿名函数前，也是可以的。&lt;/li&gt;
  &lt;li&gt;export * 命令会忽略导入模块中通过export default导出内容&lt;/li&gt;
  &lt;li&gt;使用default，注意import后面不要使用{}。即使用export default时，对应的import语句不需要使用大括号；不使用export default时，对应的import语句需要使用大括号。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 输出
  export default function defaultFn() {
    // ...
  }
  // 输入
  import defaultFn from 'defaultFn';
    
  // 输出
  export function defaultFn() {
    // ...
  };
  // 输入
  import {defaultFn} from 'defaultFn';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export default命令用于指定模块的默认输出，一个模块只能有一个默认输出。&lt;/li&gt;
  &lt;li&gt;本质上export default是输出一个叫做default的变量或方法，然后系统允许可以取任意名字
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function add(x, y) {
    return x * y;
  }
  export {add as default};  // 等同于  export default add;
    
  // app.js
  import { default as xxx } from 'modules'; // 等同于 import xxx from 'modules';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export default命令其事输出一个default的变量，因此其后不能跟变量声明语句
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 正确
  export var a = 1;
  // 正确
  var a = 1;
  export default a;
  // 错误
  export default var a = 1;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;一条import语句中，可以同时输入默认方法和其他变量
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import customName, { otherMethod } from './export-default';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;如果要输出默认的值，只需将值跟在export default之后即可
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export default 42;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export default也可以用来输出类
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // MyClass.js
  export default class { ... }
  // main.js
  import MyClass from 'MyClass';
  let o = new MyClass();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;模块的继承&quot;&gt;模块的继承&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;模块之间也可以继承
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // circleplus.js(假设circleplus模块继承circle模块)
  // 方法一
  export * from 'circle';  // 输出继承来的所有circle模块的属性和方法，忽略default方法
  export var e = 2.71828182846;
  export default function(x) {
    return Math.exp(x);
  }
  // 方法二
  export { area as circleArea } from 'circle'; // 将circle的属性或方法改名后再输出
    
  // 加载上面circleplus模块
  // main.js
  import * as math from 'circleplus';  // 加载所有属性和方法
  import exp from 'circleplus';  // 加载默认方法为exp
  console.log(exp(math.e));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;es6模块加载的实质&quot;&gt;ES6模块加载的实质&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用&lt;/li&gt;
  &lt;li&gt;CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。&lt;/li&gt;
  &lt;li&gt;ES6模块的运行机制是遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值。&lt;/li&gt;
  &lt;li&gt;ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // lib.js
  export let counter = 3;
  export function incCounter() {
    counter++;
  }
  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 3
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;以上test模块加载后，它的内部变化就影响不到输出的counter了。这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // lib.js
  var counter = 3; 		function incCounter() {     		counter++; 		} 		module.exports = {     		get counter() {         		return counter     		},     		incCounter: incCounter 		}
  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 实例一
  // lib.js
  export let counter = 3; 	export function incCounter() { 		counter++; 	}
  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4

  // 实例二
  // m1.js
  export var foo = 'bar';
  setTimeout(() =&amp;gt; foo = 'baz', 500);
  // m2.js
  import {foo} from './m1.js';
  console.log(foo);
  setTimeout(() =&amp;gt; console.log(foo), 500);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // lib.js
  export let obj = {};
  // main.js
  import { obj } from './lib';
  obj.prop = 123; // OK
  obj = {}; // TypeError:babel-compile都不会通过
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // mod.js
  function C() {
    this.sum = 0;
    this.add = function () {
      this.sum += 1;
    };
    this.show = function () {
      console.log(this.sum);
    };
  }
  export let c = new C();
  // x.js
  import {c} from './mod';
  c.add();	
  // y.js
  import {c} from './mod';
  c.show();
  // main.js
  import './x';
  import './y';
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;循环加载&quot;&gt;循环加载&lt;/h3&gt;

&lt;p&gt;“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。&lt;/p&gt;

&lt;p&gt;“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。
 目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。&lt;/p&gt;

&lt;h4 id=&quot;commonjs模块的加载原理&quot;&gt;CommonJS模块的加载原理&lt;/h4&gt;
&lt;p&gt;CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。之后即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // Node内部加载模块后生成的一个对象
 {
      id: '...',   // 加载模块名
      exports: { ... },  // 模块输出的各个接口
      loaded: true,  // 布尔值，表示该模块的脚本是否执行完毕
      ...
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;commonjs模块的循环加载&quot;&gt;CommonJS模块的循环加载&lt;/h4&gt;
&lt;p&gt;CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，未执行的部分不会输出。
    ````
    // a.js
    console.log(‘a starting’);
    exports.done = false;
    const b = require(‘./b.js’);
    console.log(‘in a, b.done = %j’, b.done);
    exports.done = true;
    console.log(‘a done’);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//b.js
console.log('b starting');
exports.done = false;
const a = require('./a.js');  //此时只执行a.js的第一行，发生循环加载，系统会去a.js模块对应对象的exports取值，但还没执行完，因此只能取部分值(一旦require就会生成对象，然后一步步执行，同时往对象加值)。
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');

// main.js
console.log('main starting');
const a = require('./a.js');
const b = require('./b.js');  // 已经加载，只会从缓存中取值
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);

// 执行结果
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
``` - 备注
- 由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;es6模块的循环加载&quot;&gt;ES6模块的循环加载&lt;/h4&gt;

&lt;p&gt;ES6模块是动态引用，如果使用import从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // a.js如下
    import {bar} from './b.js';  //加载b，所以先执行b.js
    console.log('a.js');  // 加载a，但是a已经在执行了，所以不会重复执行，因此继续往下执行b.js
    console.log(bar);
    export let foo = 'foo';
    
    // b.js
    import {foo} from './a.js';
    console.log('b.js');
    console.log(foo);
    export let bar = 'bar';
    
    // 执行结果
    b.js
    undefined
    a.js
    bar
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;考考你&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // a.js
  import {bar} from './b.js';  // 建立引用，从b.js引用‘bar’
  export function foo() {
    console.log('foo');
    bar();  // 到b.js执行bar
    console.log('执行完毕');
  }
  foo();  // 执行时，引用都已完全建立
    
  // b.js
  import {foo} from './a.js';  // 建立引用，从a.js引用foo
  export function bar() {
    console.log('bar');
    if (Math.random() &amp;gt; 0.5) { // 递归执行foo，一旦随机数小于等于0.5就停止执行
      foo();
    }
  }
    
  // 执行结果
  // Math.random() &amp;lt;= 0.5
  foo
  bar
  执行完毕
    
  // Math.random() &amp;gt; 0.5
  foo
  bar
  foo
  bar
  执行完毕
  执行完毕
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md&quot;&gt;如何测试例子&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;跨模块常量&quot;&gt;跨模块常量&lt;/h3&gt;

&lt;p&gt;const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），可讲常量设置为一个单独的模块，可用以下代码实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from './constants';
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import {A, B} from './constants';
console.log(A); // 1
console.log(B); // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;es6模块的转码&quot;&gt;ES6模块的转码&lt;/h3&gt;
&lt;p&gt;浏览器目前还不支持ES6模块，现在要使用需要将其转换为ES5写法，有三种方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用Babel&lt;/li&gt;
  &lt;li&gt;ES6 module transpiler
    &lt;ul&gt;
      &lt;li&gt;定义:square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。&lt;/li&gt;
      &lt;li&gt;使用
        &lt;ul&gt;
          &lt;li&gt;安装这个转码器:  npm install -g es6-module-transpiler&lt;/li&gt;
          &lt;li&gt;文件转码: 使用compile-modules convert命令转码，-o参数可以指定转码后文件名
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   // 其中file1.js和file2.js是需要转换的es6文件
   compile-modules convert file1.js file2.js 
   // -o指定转码后的文件名，如果不指定，则默认在命令行输出转换后代码。out1.js如果不存在则会自动生成
   $ compile-modules convert file1.js file2.js -o out1.js out2.js
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SystemJS
    &lt;ul&gt;
      &lt;li&gt;定义: 它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google的Traceur转码器。&lt;/li&gt;
      &lt;li&gt;使用
        &lt;ul&gt;
          &lt;li&gt;首先在网页内载入system.js文件&lt;/li&gt;
          &lt;li&gt;接着使用System.import方法加载模块文件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;备注
        &lt;ul&gt;
          &lt;li&gt;System.import使用异步加载，返回一个Promise对象，可以针对这个对象编程&lt;/li&gt;
          &lt;li&gt;在使用System.import之前需要在页面引入Google的Traceur转码器&lt;/li&gt;
          &lt;li&gt;加载的时候js文件要有后缀&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;阅读书籍&quot;&gt;阅读书籍&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://web.jobbole.com/82238/&quot;&gt;UMD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ModuleLoader/es6-module-loader/issues/95&quot;&gt;script type=module&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_cycles&quot;&gt;Node官方加载文档-使用CommonJs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md&quot;&gt;Es6-symbol加载-使用Module&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/esnext/es6-module-transpiler&quot;&gt;module-transpiler&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.gaoqixhb.com/p/55783789cef7e0a008d5d6ef&quot;&gt;Google Traceur&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/module&quot;&gt;Module&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/05/02/ES6-Module/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/02/ES6-Module/</guid>
        
        <category>ES6</category>
        
        <category>基础整理</category>
        
        
      </item>
    
      <item>
        <title>yeoman简介与npm发包</title>
        <description>&lt;h1 id=&quot;yeoman&quot;&gt;YEOMAN&lt;/h1&gt;
&lt;p&gt;yeoman脚手架工具
Generators: 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;yo&lt;/code&gt;命令来生成文件&lt;/p&gt;
&lt;h2 id=&quot;组织自己的generators&quot;&gt;组织自己的generators&lt;/h2&gt;
&lt;h3 id=&quot;设置为一个node-module&quot;&gt;设置为一个node module&lt;/h3&gt;
&lt;p&gt;generator的核心就是node模块&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个名为’generator-XX’的文件夹。
    &lt;ul&gt;
      &lt;li&gt;Yeoman会依旧依赖稳健系统查找可用的generators&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件中创建&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;文件
    &lt;ul&gt;
      &lt;li&gt;可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;npm init&lt;/code&gt;创建&lt;/li&gt;
      &lt;li&gt;name必须要有&lt;code class=&quot;highlighter-rouge&quot;&gt;generator-&lt;/code&gt;前缀&lt;/li&gt;
      &lt;li&gt;关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;keywords&lt;/code&gt;必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;yeoman-generator&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;必须确保使用最新版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;yeoman-generator&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save yeoman-generator&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件目录
    &lt;ul&gt;
      &lt;li&gt;可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt;&lt;a href=&quot;https://github.com/yeoman/generator-generator&quot;&gt;generator-generator&lt;/a&gt;该项目，参考其内容&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;扩展generator
    &lt;ul&gt;
      &lt;li&gt;扩展基础generator
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      var Generator = require('yeoman-generator');
      module.exports = class extends Geneator{};
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;覆盖constructor方法
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constructor(args, opts) {
   super(args, opts);
   this.option('babel');
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;添加自己的功能
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; module.exports = class extends Generator {
    // overwrite constructor
    constructor(args, opts) {
       super(args, opts);
       this.option('babel');
    }
	   
    method1() {
       this.log('method 1 just ran');
    }
	   
    method2() {
       this.log('method 2 just ran');
    }
 };
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;运行generator
    &lt;ul&gt;
      &lt;li&gt;本地开发generator，不能作为全局npm module使用&lt;/li&gt;
      &lt;li&gt;使用npm创建全局module,并且和本地的建立链接&lt;/li&gt;
      &lt;li&gt;文件根目录下，运行&lt;code class=&quot;highlighter-rouge&quot;&gt;npm link&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;运行此命令之前需要进行npm发包，发包过程如下&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;link成功之后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;yo name&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;踩坑&lt;/em&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yo name&lt;/code&gt;命令中一定要使用name,而创建自己的generator必须要以generator-为前缀，即文件名为&lt;code class=&quot;highlighter-rouge&quot;&gt;generator-name&lt;/code&gt;。则使用&lt;code class=&quot;highlighter-rouge&quot;&gt;yo name&lt;/code&gt;的时候，只使用后面的name&lt;/li&gt;
          &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;yo name&lt;/code&gt;之前，要保证yo和generator-name安装在同一目录下，如yo是全局安装，则generator-name也要是全局安装。&lt;em&gt;yo XXX 的时候，在yo里要执行require(‘generator-XXX’)，因此位置必须统一&lt;/em&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;npm发包&quot;&gt;npm发包&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;注册账号&lt;/li&gt;
  &lt;li&gt;添加package.json文件，发包
    &lt;ul&gt;
      &lt;li&gt;npm publish&lt;/li&gt;
      &lt;li&gt;踩坑: 因为使用了公司npm镜像，然后莫名一直安装失败，只有使用&lt;code class=&quot;highlighter-rouge&quot;&gt;npm config set registry https://registry.npmjs.org/&lt;/code&gt;之后，再进行&lt;code class=&quot;highlighter-rouge&quot;&gt;npm publish&lt;/code&gt;才能成功&lt;/li&gt;
      &lt;li&gt;心得: 一定要看log文件，比在网上查好得多！！&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 28 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/28/yeoman-npm/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/28/yeoman-npm/</guid>
        
        <category>yeoman</category>
        
        <category>npm</category>
        
        <category>学习</category>
        
        
      </item>
    
  </channel>
</rss>
